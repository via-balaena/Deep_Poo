<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CortenForge Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-85906508.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-433c19f3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">CortenForge Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="cortenforge-book"><a class="header" href="#cortenforge-book">CortenForge Book</a></h1>
<p>This book is a concise, end-to-end guide to the CortenForge workspace: a high-level overview, a practical “Building Apps” guide, a calm crate overview, and optional deep dives. It minimizes redundancy by pushing API detail to docs.rs and source links while keeping the mental model and integration steps here.</p>
<p>How to use this book:</p>
<ul>
<li>Start with the Workspace chapter for the architecture map and shared constraints.</li>
<li>Use Building Apps to assemble a real app stack and trace the core flows.</li>
<li>Dive into Crate chapters only when you need implementation details.</li>
</ul>
<p>If you need a quick answer, search for the crate name and jump to its overview page.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="workspace"><a class="header" href="#workspace">Workspace</a></h1>
<p><strong>Why</strong>: The big, calm map of the whole project.
<strong>How it fits</strong>: Gives you the mental model before details.
<strong>Learn more</strong>: If you want a story path, jump to <a href="20_building_apps/README.html">Building Apps</a>.</p>
<p>This chapter answers, “What is CortenForge, and how do the pieces fit?”</p>
<p>What you will get:</p>
<ul>
<li>a simple mental model of the crate landscape</li>
<li>the main data/runtime flows in one place</li>
<li>the contracts that keep capture, training, and inference aligned</li>
</ul>
<p>How to use it:</p>
<ul>
<li>skim the overview first</li>
<li>follow links when you want depth</li>
<li>if this feels heavy, jump to Building Apps and come back later</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="workspace-overview"><a class="header" href="#workspace-overview">Workspace overview</a></h1>
<p><strong>Why</strong>: The single “big picture” view of the workspace.
<strong>How it fits</strong>: Read it once, then follow links as needed.
<strong>Learn more</strong>: See <a href="20_building_apps/README.html">Building Apps</a> for the guided path.</p>
<p>Package names use hyphens (e.g., <code>cortenforge-tools</code>), while Rust crate imports use underscores (e.g., <code>cortenforge_tools</code>).</p>
<h1 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h1>
<p>One diagram that shows how the crates lean on each other.</p>
<pre class="mermaid">flowchart LR
    CLI[cli_support]
    BD[burn_dataset]
    TOOLS[cortenforge-tools]
    CU[capture_utils]
    SC[sim_core]
    VC[vision_core]
    VR[vision_runtime]
    DC[data_contracts]
    TR[training]
    INF[inference]
    M[models]
    CF[cortenforge]

    TOOLS --&gt; CLI
    TOOLS --&gt; BD
    TOOLS --&gt; CU
    TOOLS --&gt; DC
    TOOLS --&gt; INF
    TOOLS --&gt; M

    BD --&gt; DC
    CU --&gt; DC
    VR --&gt; SC
    VR --&gt; VC
    VR --&gt; INF
    INF --&gt; SC
    INF --&gt; VC
    INF --&gt; M
    TR --&gt; DC
    TR --&gt; M
    CF --&gt; SC
    CF --&gt; VC
    CF --&gt; VR
    CF --&gt; DC
    CF --&gt; CU
    CF --&gt; M
    CF --&gt; TR
    CF --&gt; INF
    CF --&gt; CLI
    CF --&gt; BD
    CF --&gt; TOOLS
</pre>

<details>
<summary>Dependency Graph Interpretation</summary>
<h2 id="interpretation"><a class="header" href="#interpretation">Interpretation</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Area</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td>Core runtime path</td><td><code>sim_core</code>, <code>vision_core</code>, and <code>vision_runtime</code> drive runtime, capture, and inference; inference hooks up detectors; models provides TinyDet/BigDet.</td></tr>
<tr><td>Runtime entry point</td><td>Apps typically start with <code>sim_core::build_app</code>, then add <code>vision_runtime</code> capture/inference plugins; hooks wire controls/autopilot.</td></tr>
<tr><td>Capture output</td><td><code>vision_runtime</code> emits <code>FrameRecord</code>s; <code>capture_utils</code> recorders write JSON + images using <code>data_contracts</code> schemas.</td></tr>
<tr><td>Data path</td><td><code>data_contracts</code> defines schemas; <code>capture_utils</code> and tools use them; <code>burn_dataset</code> consumes schemas for Burn loaders.</td></tr>
<tr><td>Dataset ingestion</td><td><code>burn_dataset</code> indexes/validates capture runs, builds Burn-compatible batches/iterators used by <code>training</code>.</td></tr>
<tr><td>Training path</td><td><code>training</code> depends on <code>models</code> and <code>data_contracts</code> to produce <a href="https://dataconomy.com/2025/05/09/what-is-machine-learning-checkpointing/">checkpoints</a>; <code>inference</code> consumes them.</td></tr>
<tr><td>Training to inference</td><td><code>training</code> writes checkpoints; <code>inference</code> loads them to build detectors used by runtime or tools.</td></tr>
<tr><td>Tooling</td><td><code>cortenforge-tools</code> wraps CLI helpers (<code>cli_support</code>), recorder/capture (<code>capture_utils</code>), schemas (<code>data_contracts</code>), dataset (<code>burn_dataset</code>), and inference/models; <strong>planned to be split into app-agnostic vs. app-specific pieces in the future.</strong></td></tr>
<tr><td>Umbrella</td><td><code>cortenforge</code> re-exports the stack with feature wiring.</td></tr>
<tr><td>Dependency direction</td><td>Arrows generally point from higher-level crates to lower-level foundations; <code>data_contracts</code> and <code>vision_core</code> sit on many paths.</td></tr>
<tr><td>Change impact</td><td>Schema changes in <code>data_contracts</code> or interface changes in <code>vision_core</code> ripple across capture, training, and tools.</td></tr>
</tbody>
</table>
</div>
</details>
<br> 
<h2 id="core-crates-high-centrality"><a class="header" href="#core-crates-high-centrality">Core crates (high centrality)</a></h2>
<p>Critical foundations for runtime, contracts, and model definitions.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Version</th><th>Path</th><th>Type</th><th>Edition</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><strong>cortenforge-sim-core</strong></td><td>0.1.1</td><td>sim_core</td><td>lib</td><td>2021</td><td>Bevy runtime scaffolding, hooks, recorder types</td></tr>
<tr><td><strong>cortenforge-vision-core</strong></td><td>0.1.1</td><td>vision_core</td><td>lib</td><td>2021</td><td>Vision interfaces, overlay math</td></tr>
<tr><td><strong>cortenforge-data-contracts</strong></td><td>0.1.1</td><td>data_contracts</td><td>lib</td><td>2021</td><td>Schemas/validation for captures/warehouse</td></tr>
<tr><td><strong>cortenforge-models</strong></td><td>0.1.1</td><td>models</td><td>lib</td><td>2021</td><td>TinyDet/BigDet definitions</td></tr>
</tbody>
</table>
</div>
<br>
<details>
<summary><strong>Rationale</strong></summary>
<p>Core crates sit on the critical path of runtime (sim_core/vision_core) and data contracts/models that feed training/inference.</p>
</details>
<h2 id="mid-layer"><a class="header" href="#mid-layer">Mid-layer</a></h2>
<p>Crates that adapt core capabilities into training, inference, and tooling utilities.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Version</th><th>Path</th><th>Type</th><th>Edition</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><strong>cortenforge-inference</strong></td><td>0.1.1</td><td>inference</td><td>lib</td><td>2021</td><td>Detector factory (Burn-backed/heuristic)</td></tr>
<tr><td><strong>cortenforge-training</strong></td><td>0.1.1</td><td>training</td><td>lib + bins</td><td>2021</td><td>Burn training/eval CLI (train/eval bins)</td></tr>
<tr><td><strong>cortenforge-capture-utils</strong></td><td>0.1.1</td><td>capture_utils</td><td>lib</td><td>2021</td><td>Recorder sinks and capture helpers</td></tr>
<tr><td><strong>cortenforge-burn-dataset</strong></td><td>0.1.1</td><td>crates/burn_dataset</td><td>lib</td><td>2021</td><td>Burn dataset loading/splitting</td></tr>
<tr><td><strong>cortenforge-cli-support</strong></td><td>0.1.1</td><td>crates/cli_support</td><td>lib</td><td>2021</td><td>Shared CLI args/helpers; optional Bevy feature</td></tr>
</tbody>
</table>
</div>
<br>
<details>
<summary><strong>Rationale</strong></summary>
<p>Mid-layer crates adapt core capabilities to specific tasks (detector factory, training, recorder sinks, CLI parsing).</p>
</details>
<h2 id="leafruntime-tooling"><a class="header" href="#leafruntime-tooling">Leaf/runtime tooling</a></h2>
<p>Runtime glue and app-facing tooling crates with fewer inward dependencies.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Version</th><th>Path</th><th>Type</th><th>Edition</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><strong>cortenforge-vision-runtime</strong></td><td>0.1.1</td><td>vision_runtime</td><td>lib</td><td>2021</td><td>Capture/inference plugins for Bevy</td></tr>
<tr><td><strong>cortenforge-tools</strong></td><td>0.1.1</td><td>tools</td><td>lib + bins</td><td>2021</td><td>Tooling crate (crate <code>cortenforge_tools</code>); bins include overlay/prune/etl/export/cmd/single_infer; app-facing bins gated by features</td></tr>
</tbody>
</table>
</div>
<br>
<details>
<summary><strong>Rationale</strong></summary>
<p>Leaf/runtime tooling crates are consumers or runtime glue with fewer inward dependencies.</p>
</details>
<h2 id="umbrella"><a class="header" href="#umbrella">Umbrella</a></h2>
<p>Single entry-point facade that re-exports the stack behind feature flags.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Version</th><th>Path</th><th>Type</th><th>Edition</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><strong>cortenforge</strong></td><td>0.1.1</td><td>crates/cortenforge</td><td>lib</td><td>2024</td><td>Umbrella re-export; feature wiring</td></tr>
</tbody>
</table>
</div>
<br>
<details>
<summary><strong>Rationale</strong></summary>
<p>The umbrella crate is a facade that re-exports the stack with feature wiring.</p>
</details>
<br>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="shared-dependency-themes-1"><a href="#shared-dependency-themes-1" class="header">Shared Dependency Themes</a></h1>
<h2 id="shared-dependency-themes"><a class="header" href="#shared-dependency-themes">Shared dependency themes</a></h2>
<p><strong>Why</strong>: A quick sense of the external libraries the workspace leans on.
<strong>How it fits</strong>: Helps you understand upgrade risk and shared constraints.
<strong>Learn more</strong>: See <a href="#workspace-metadata">Workspace Metadata</a> for publish posture.
High-level overview of the shared third-party dependencies across the workspace. Use this as a
map, not a full inventory.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Theme</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td>Burn</td><td>Burn 0.14 (burn-core 0.14.1) across models/training/inference; burn-ndarray and burn-wgpu backends.</td></tr>
<tr><td>Errors/serde</td><td>serde/serde_json, anyhow/thiserror for errors.</td></tr>
<tr><td>Serialization</td><td>bincode 2.0.0-rc.3 for checkpoint/weight formats.</td></tr>
<tr><td>Bevy/Rapier</td><td>bevy for sim_core/vision_runtime and some tools; bevy_rapier3d for physics integration in sim_core.</td></tr>
<tr><td>CLI</td><td>clap for CLIs; cli_support reused by tools.</td></tr>
<tr><td>Data/IO</td><td>image/png, rayon for capture/tools; arrow/parquet in tools.</td></tr>
<tr><td>Hashing</td><td>sha2 for content hashing in capture/tools.</td></tr>
<tr><td>Temp/FS</td><td>tempfile for tests and local staging.</td></tr>
</tbody>
</table>
</div>
<h2 id="workspace-dependency-policy"><a class="header" href="#workspace-dependency-policy">Workspace dependency policy</a></h2>
<ul>
<li>Shared third-party deps should be centralized in root <code>[workspace.dependencies]</code>.</li>
<li>Member crates should use <code>workspace = true</code> and keep crate-specific features in place.</li>
<li>Optional deps remain optional in member crates.</li>
<li>Single-use deps may stay per-crate to keep the workspace list focused.</li>
<li><strong>Bevy is the exception today</strong>: crates are split on default features, so it stays per-crate
until the feature set is unified. After that, centralize Bevy.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h1>
<p><strong>Why</strong>: Know the default feature posture before you enable anything heavy.
<strong>How it fits</strong>: Feature gates shape build size, runtime backends, and tooling.
<strong>Learn more</strong>: See <a href="#build--run">Build &amp; Run</a> for command patterns.</p>
<h2 id="workspace-wide-themes"><a class="header" href="#workspace-wide-themes">Workspace-wide themes</a></h2>
<p>High-level defaults and stack-wide feature expectations.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Theme</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td>Default backend</td><td>training/inference/models enable <code>backend-ndarray</code> by default; GPU/WGPU is opt-in via <code>backend-wgpu</code>.</td></tr>
<tr><td>Model variants</td><td><code>tinydet</code>/<code>bigdet</code> across models/training/inference.</td></tr>
<tr><td>Tools</td><td><code>tui</code>, <code>scheduler</code>, <code>gpu_nvidia</code> gate app-specific/heavy bins in cortenforge-tools.</td></tr>
<tr><td>Umbrella crate</td><td><code>cortenforge</code> re-exports features to enable stacks (sim-core, vision-core/runtime, training/inference).</td></tr>
<tr><td>Burn-core</td><td>0.14.1 fixes the prior bincode publish break; no patch required.</td></tr>
</tbody>
</table>
</div>
<h2 id="per-crate-highlights"><a class="header" href="#per-crate-highlights">Per-crate highlights</a></h2>
<p>Quick reference for feature toggles that matter most per crate.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Highlights</th></tr>
</thead>
<tbody>
<tr><td>models</td><td><code>tinydet</code> (default), <code>bigdet</code>.</td></tr>
<tr><td>training</td><td><code>backend-ndarray</code> (default), <code>backend-wgpu</code>, <code>tinydet</code> (default), <code>bigdet</code>.</td></tr>
<tr><td>inference</td><td><code>backend-ndarray</code> (default), <code>backend-wgpu</code>, <code>tinydet</code> (default), <code>bigdet</code>.</td></tr>
<tr><td>cortenforge (umbrella)</td><td>Features map to member crates (sim-core, vision-core/runtime, models, training, inference, capture-utils, cli-support, burn-dataset); <code>burn-runtime</code>/<code>burn-wgpu</code> stacks wire burn deps.</td></tr>
<tr><td>cortenforge-tools</td><td><code>tui</code>, <code>scheduler</code>, <code>gpu_nvidia</code>; defaults are lean (no extra features).</td></tr>
<tr><td>cli_support</td><td>Optional <code>bevy</code>/<code>bevy-resource</code> for resource integration.</td></tr>
<tr><td>burn_dataset</td><td><code>burn-runtime</code> wires burn + rayon/memmap2/crossbeam; <code>burn-ndarray</code>/<code>burn-wgpu</code> optional.</td></tr>
</tbody>
</table>
</div>
<h2 id="hygiene-guidance"><a class="header" href="#hygiene-guidance">Hygiene guidance</a></h2>
<p>Rules of thumb for keeping features and builds predictable.</p>
<ol>
<li>Keep defaults light (NdArray, no heavy GPU deps) to keep CI fast.</li>
<li>Gate app-specific or heavy tooling behind explicit features; avoid enabling by default.</li>
<li>When adding new features, document what they gate and ensure clippy/tests run with and without them as appropriate.</li>
<li>Avoid adding patch overrides unless needed for local development.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="integration-contracts"><a class="header" href="#integration-contracts">Integration Contracts</a></h1>
<p><strong>Why</strong>: These are the promises between crates that keep the system stable.
<strong>How it fits</strong>: When these change, many pages and flows must update.
<strong>Learn more</strong>: See <a href="#canonical-flows">Canonical Flows</a>.</p>
<p>Key assumptions and contracts between crates. Keep these in sync as APIs evolve.</p>
<h2 id="types-and-data-shapes"><a class="header" href="#types-and-data-shapes">Types and data shapes</a></h2>
<p>Shared contracts that downstream crates rely on; update with care.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Contract</th><th>Downstream crates</th><th>Impact</th></tr>
</thead>
<tbody>
<tr><td><code>vision_core::interfaces::{Frame, DetectionResult, Label, FrameRecord}</code></td><td><code>vision_runtime</code>, <code>inference</code>, <code>capture_utils</code>, recorders</td><td>Changes propagate across runtime, inference, and sinks.</td></tr>
<tr><td><code>data_contracts::capture::{CaptureMetadata, PolypLabel}</code></td><td><code>capture_utils</code>, <code>burn_dataset</code>, tools</td><td>Recorder outputs and dataset loaders assume this schema; validators and ETL rely on fields being stable.</td></tr>
<tr><td><code>burn_dataset</code> tensors</td><td><code>training</code>, <code>inference</code>, <code>models</code></td><td><code>BatchIter</code>/<code>collate</code> expect consistent image dimensions per batch and <code>max_boxes</code> alignment.</td></tr>
<tr><td><code>models</code> output</td><td><code>training</code>, <code>inference</code></td><td><code>TinyDet</code>/<code>BigDet</code> scores align with <code>max_boxes</code>; inference and training must agree on this.</td></tr>
</tbody>
</table>
</div>
<h2 id="feature-expectations"><a class="header" href="#feature-expectations">Feature expectations</a></h2>
<p>Feature flags that have cross-crate implications.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expectation</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td>Backends</td><td>Default NdArray; enable <code>backend-wgpu</code> in <code>models</code>, <code>training</code>, <code>inference</code> to use GPU.</td></tr>
<tr><td>Models</td><td><code>bigdet</code> feature switches inference model type; downstream code should not assume TinyDet dimensions when <code>bigdet</code> is on.</td></tr>
<tr><td>Thread safety</td><td><code>vision_runtime</code> assumes detectors are <code>Send + Sync</code>; <code>InferenceFactory</code> supplies such detectors.</td></tr>
<tr><td>Tooling features</td><td><code>cortenforge-tools</code> bins: <code>tui</code>, <code>scheduler</code>, <code>gpu_nvidia</code> gate heavy deps; default footprint is minimal.</td></tr>
</tbody>
</table>
</div>
<h2 id="runtime-assumptions"><a class="header" href="#runtime-assumptions">Runtime assumptions</a></h2>
<p>Operational assumptions that affect how runtime and tooling behave.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Assumption</th><th>Implication</th></tr>
</thead>
<tbody>
<tr><td><code>vision_runtime::CapturePlugin</code> runs only in <code>Datagen</code>/<code>Inference</code></td><td>App must set <code>sim_core::SimRunMode</code> accordingly.</td></tr>
<tr><td>Single detector in inference loop</td><td>Async tasks swap detector instances without locks; throughput is limited.</td></tr>
<tr><td>Capture layout (<code>run_dir/images</code>, <code>labels</code>, <code>overlays</code>)</td><td>Recorders/datasets/tools expect this structure.</td></tr>
<tr><td><code>burn_dataset::BatchIter</code> size expectations</td><td>Consistent image sizes required unless <code>target_size</code> forces resizing.</td></tr>
<tr><td>Permissive env vars</td><td><code>BURN_DATASET_*</code>/<code>WAREHOUSE_*</code> affect behavior; CI/publish should set explicitly.</td></tr>
<tr><td><code>cortenforge-tools</code> unpublished</td><td>App-specific bins belong in app repos; shared helpers may migrate.</td></tr>
</tbody>
</table>
</div>
<h2 id="errorcompatibility-expectations"><a class="header" href="#errorcompatibility-expectations">Error/compatibility expectations</a></h2>
<p>How failures propagate and what must stay in sync.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expectation</th><th>Implication</th></tr>
</thead>
<tbody>
<tr><td>Inference fallback</td><td>If model weights can’t be loaded, inference switches to a heuristic detector—apps should make that visible (e.g., a status banner or log).</td></tr>
<tr><td>Dataset errors</td><td><code>BurnDatasetError</code> informs whether to skip (permissive) or fail-fast in training/ETL.</td></tr>
<tr><td>Schema/interface changes</td><td>Updates to <code>data_contracts</code> or <code>vision_core</code> require coordinated changes across recorders, loaders, and runtime.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="canonical-flows"><a class="header" href="#canonical-flows">Canonical Flows</a></h1>
<p><strong>Why</strong>: See the end-to-end paths without diving into every crate.
<strong>How it fits</strong>: Use this when you need a system-level mental model.
<strong>Learn more</strong>: Follow the guided path in <a href="20_building_apps/README.html">Building Apps</a>.</p>
<p>Below are the key end-to-end flows that stitch the crates together. Each diagram highlights the crate touchpoints and the primary data moving through them.</p>
<h2 id="1-capture--labels--overlays"><a class="header" href="#1-capture--labels--overlays">1) Capture → Labels → Overlays</a></h2>
<pre class="mermaid">flowchart LR
    A["sim_core&lt;br/&gt;(Bevy app, ModeSet)"] --&gt; B["vision_core&lt;br/&gt;interfaces"]
    B --&gt; C["vision_runtime&lt;br/&gt;capture plugin"]
    C --&gt; D[capture_utils::JsonRecorder]
    D --&gt; E["data_contracts&lt;br/&gt;CaptureMetadata/Label"]
    D --&gt; F["capture_utils::generate_overlays&lt;br/&gt;(vision_core::overlay)"]
</pre>

<p>Steps:</p>
<ol>
<li><code>sim_core</code> sets up Bevy app + modes; <code>vision_core</code> interfaces define <code>Frame</code>/<code>Recorder</code>.</li>
<li><code>vision_runtime::CapturePlugin</code> captures frames/readback; emits <code>FrameRecord</code>s.</li>
<li><code>capture_utils::JsonRecorder</code> writes labels (<code>CaptureMetadata</code>) to disk using <code>data_contracts</code>.</li>
<li><code>capture_utils::generate_overlays</code> draws boxes via <code>vision_core::overlay</code> to create PNG overlays.</li>
</ol>
<p>Notes:</p>
<ul>
<li>Default pipeline is NdArray-only; GPU paths are feature-gated.</li>
<li>Recorder sink is pluggable; swap in other sinks if needed.</li>
</ul>
<h2 id="2-capture--warehouse-etl--training"><a class="header" href="#2-capture--warehouse-etl--training">2) Capture → Warehouse ETL → Training</a></h2>
<pre class="mermaid">flowchart LR
    A["capture_utils&lt;br/&gt;(run dir)"] --&gt; B["burn_dataset&lt;br/&gt;index_runs/validate"]
    B --&gt; C["burn_dataset&lt;br/&gt;BatchIter/warehouse shards"]
    C --&gt; D["training::collate&lt;br/&gt;+ models"]
    D --&gt; E["training::run_train&lt;br/&gt;(backends via TrainBackend)"]
</pre>

<p>Steps:</p>
<ol>
<li>Use <code>burn_dataset::index_runs</code> / <code>summarize_with_thresholds</code> to validate captured runs.</li>
<li>Build <code>BatchIter</code> or warehouse loaders (in-memory or streaming) to produce Burn tensors.</li>
<li><code>training::collate</code> shapes batches (images/boxes/features); <code>models</code> provide <code>TinyDet</code>/<code>BigDet</code>.</li>
<li><code>training::run_train</code> (CLI/bin) runs the training loop on NdArray or WGPU backend.</li>
</ol>
<p>Notes:</p>
<ul>
<li>Batch images must share dimensions unless you add resize/pad; <code>max_boxes</code> drives tensor shapes.</li>
<li>Env flags (<code>BURN_DATASET_PERMISSIVE</code>, <code>WAREHOUSE_STORE</code>, etc.) tune performance/strictness.</li>
</ul>
<h2 id="3-checkpointed-inference-runtime"><a class="header" href="#3-checkpointed-inference-runtime">3) Checkpointed Inference Runtime</a></h2>
<pre class="mermaid">flowchart LR
    A["burn_dataset&lt;br/&gt;+ training&lt;br/&gt;(checkpoint)"] --&gt; B[inference::InferenceFactory]
    B --&gt;|Detector| C[vision_runtime::InferencePlugin]
    C --&gt; D[vision_core::DetectionResult]
    D --&gt; E["overlay/logging&lt;br/&gt;DetectionOverlayState"]
</pre>

<p>Steps:</p>
<ol>
<li>Take a Burn checkpoint produced by training (<code>models</code> weights).</li>
<li><code>inference::InferenceFactory</code> loads it (or falls back to heuristic).</li>
<li><code>vision_runtime::InferencePlugin</code> schedules async inference on captured frames (ModeSet::Inference).</li>
<li>Results populate <code>DetectionOverlayState</code> (boxes/scores/fallback) for UI/recorder consumption.</li>
</ol>
<p>Notes:</p>
<ul>
<li>Mutex-guarded detector serializes inference; for higher throughput, consider per-thread detectors.</li>
<li>Hotkeys can adjust thresholds and force heuristic fallback at runtime.</li>
</ul>
<h2 id="4-tooling--orchestration-optional-bins"><a class="header" href="#4-tooling--orchestration-optional-bins">4) Tooling &amp; Orchestration (optional bins)</a></h2>
<pre class="mermaid">flowchart LR
    A["cli_support&lt;br/&gt;args/helpers"] --&gt; B[cortenforge_tools::services]
    B --&gt; C["sim_view/train binaries&lt;br/&gt;(external)"]
    B --&gt; D["cortenforge_tools::warehouse_commands&lt;br/&gt;env/cmd builder"]
</pre>

<p>Steps:</p>
<ol>
<li>Parse CLI options with <code>cli_support</code> and shared helpers in <code>cortenforge_tools::services</code>.</li>
<li>Launch simulation/datagen (<code>sim_view</code>) or training (<code>train</code>) via <code>ServiceCommand</code>.</li>
<li>Build warehouse command lines with <code>warehouse_commands</code> for scripted runs.</li>
</ol>
<p>Notes:</p>
<ul>
<li><code>cortenforge-tools</code> is slated for split/trim; app-specific bins should move to the app repo.</li>
<li>Keep <code>cortenforge-tools</code> unpublished; shared bits can migrate into other crates over time.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="readers-guide"><a class="header" href="#readers-guide">Reader’s Guide</a></h1>
<p><strong>Why</strong>: Get a gentle path through the book without overwhelm.
<strong>How it fits</strong>: Use this when you only have a few minutes.
<strong>Learn more</strong>: Start with <a href="20_building_apps/README.html">Building Apps</a>.</p>
<p>Use this book to get up to speed quickly on the CortenForge crates.</p>
<h2 id="if-you-have-10-minutes"><a class="header" href="#if-you-have-10-minutes">If you have 10 minutes</a></h2>
<ol>
<li>Read <code>Workspace Overview</code> to see what exists.</li>
<li>Skim <code>Canonical Flows</code> to see end-to-end paths (capture → train → inference).</li>
<li>Open <a href="10_crates/README.html">Crate Overview</a> and read the crate you care about most.</li>
</ol>
<p>Naming note: package names use hyphens (e.g., <code>cortenforge-tools</code>), while Rust crate imports use underscores (e.g., <code>cortenforge_tools</code>).</p>
<h2 id="if-youre-diving-into-a-crate"><a class="header" href="#if-youre-diving-into-a-crate">If you’re diving into a crate</a></h2>
<ol>
<li>Start in <a href="10_crates/README.html">Crate Overview</a> and read the crate’s README.</li>
<li>If you need depth, jump to <a href="#crate-deep-dives">Crate Deep Dives</a> for public API, lifecycle, and design notes.</li>
<li>Use docs.rs for exact signatures.</li>
</ol>
<h2 id="if-youre-building-an-app"><a class="header" href="#if-youre-building-an-app">If you’re building an app</a></h2>
<ol>
<li>Read <code>Building Apps</code> in order (Step 1 → Step 9).</li>
<li>Follow the story to add one small piece at a time.</li>
<li>Jump into crate pages only when you need implementation detail.</li>
</ol>
<h2 id="for-architectureflow-questions"><a class="header" href="#for-architectureflow-questions">For architecture/flow questions</a></h2>
<ul>
<li><code>canonical_flows.md</code>: how crates stitch together.</li>
<li><code>workspace_metadata.md</code>: workspace-wide resolver, patch overrides, and feature policy.</li>
<li><code>integration_contracts.md</code>: shared types, feature expectations, runtime assumptions.</li>
</ul>
<h2 id="for-docs-maintenance"><a class="header" href="#for-docs-maintenance">For docs maintenance</a></h2>
<ol>
<li>Follow <code>quality_gates.md</code> to keep pages consistent.</li>
<li>See <code>maintenance_routine.md</code> for weekly release hygiene.</li>
</ol>
<h2 id="links-and-source"><a class="header" href="#links-and-source">Links and source</a></h2>
<ul>
<li>Prefer repo-relative source links with line anchors (<code>crate/src/module.rs:L123</code>); see <code>linking_style.md</code>.</li>
<li>docs.rs links are supplementary for exact signatures.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-apps"><a class="header" href="#building-apps">Building Apps</a></h1>
<p>This chapter is a calm, step-by-step story for building a real app with CortenForge. Each page adds one small piece, shows how it fits, and points you to crate pages + docs.rs for deeper detail.</p>
<p>How to read:</p>
<ul>
<li>Go in order. Every page is short and predictable.</li>
<li>Each step ends with an “Unlocked” line so you feel progress.</li>
<li>If you want detail, follow the links instead of reading long text here.</li>
</ul>
<p>Story arc (AstroForge Surveyor):</p>
<ul>
<li>A scout ship navigates an asteroid field.</li>
<li>It tags promising rocks.</li>
<li>It learns from captures.</li>
<li>It deploys a detector in real time.</li>
<li>It schedules and monitors runs like mission control.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 1 of 9
Progress: [#––––]</p>
<h1 id="we-set-the-mission"><a class="header" href="#we-set-the-mission">We set the mission</a></h1>
<p><strong>Why</strong>
We are building a calm, capable scout ship. It navigates an asteroid field, tags promising rocks, and learns to spot them faster over time.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>Story first, code second.</li>
<li>Every next page adds one small part.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li>Just read this step and keep going.</li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Next step: <a href="#we-choose-a-small-stack">Choose a small stack</a></li>
</ul>
<p><strong>Unlocked</strong>
You now have a clear mission and a reason to build the app.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 2 of 9
Progress: [##—––]</p>
<h1 id="we-choose-a-small-stack"><a class="header" href="#we-choose-a-small-stack">We choose a small stack</a></h1>
<p><strong>Why</strong>
Starting small keeps learning calm. We only add crates when the story needs them.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>Start with simulation + vision + capture.</li>
<li>Add training and inference later.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-sim-core</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate index: <a href="10_crates/README.html">Crate Overview</a></li>
<li>Workspace map: <a href="#workspace-overview">Workspace Overview</a></li>
</ul>
<p><strong>Unlocked</strong>
You have a minimal stack to begin the journey.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 3 of 9
Progress: [###——]</p>
<h1 id="we-add-the-ship-body-sim_core"><a class="header" href="#we-add-the-ship-body-sim_core">We add the ship body (sim_core)</a></h1>
<p><strong>Why</strong>
<code>sim_core</code> gives us the simulation scaffold: modes, plugins, and the base runtime loop.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>It is the “world” our ship lives in.</li>
<li>Everything else plugs into this loop.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-sim-core</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate page: <a href="10_crates/sim_core/README.html">sim_core</a></li>
<li>docs.rs: https://docs.rs/cortenforge-sim-core</li>
</ul>
<p><strong>Unlocked</strong>
The ship has a body to fly.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 4 of 9
Progress: [####—–]</p>
<h1 id="we-add-eyes-vision_runtime--vision_core"><a class="header" href="#we-add-eyes-vision_runtime--vision_core">We add eyes (vision_runtime + vision_core)</a></h1>
<p><strong>Why</strong>
<code>vision_core</code> defines detections; <code>vision_runtime</code> wires detectors into the sim loop.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>Frames go in, detections come out.</li>
<li>This is how the ship “sees”.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-vision-core -p cortenforge-vision-runtime</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate page: <a href="10_crates/vision_core/README.html">vision_core</a></li>
<li>Crate page: <a href="10_crates/vision_runtime/README.html">vision_runtime</a></li>
<li>docs.rs: https://docs.rs/cortenforge-vision-core and https://docs.rs/cortenforge-vision-runtime</li>
</ul>
<p><strong>Unlocked</strong>
The ship can now see the field.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 5 of 9
Progress: [#####––]</p>
<h1 id="we-add-a-recorder-capture_utils--data_contracts"><a class="header" href="#we-add-a-recorder-capture_utils--data_contracts">We add a recorder (capture_utils + data_contracts)</a></h1>
<p><strong>Why</strong>
Captures turn live runs into training data. Schemas keep those captures consistent.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>Recorder saves frames + labels.</li>
<li><code>data_contracts</code> defines the shape of that data.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-capture-utils -p cortenforge-data-contracts</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate page: <a href="10_crates/capture_utils/README.html">capture_utils</a></li>
<li>Crate page: <a href="10_crates/data_contracts/README.html">data_contracts</a></li>
<li>docs.rs: https://docs.rs/cortenforge-capture-utils and https://docs.rs/cortenforge-data-contracts</li>
</ul>
<p><strong>Unlocked</strong>
The ship can now remember what it saw.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 6 of 9
Progress: [######—]</p>
<h1 id="we-turn-captures-into-datasets-burn_dataset"><a class="header" href="#we-turn-captures-into-datasets-burn_dataset">We turn captures into datasets (burn_dataset)</a></h1>
<p><strong>Why</strong>
Training needs batches. <code>burn_dataset</code> turns captures into tensors the model can learn from.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>Captures become indexed samples.</li>
<li>Samples become batches for training.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-burn-dataset</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate page: <a href="10_crates/burn_dataset/README.html">burn_dataset</a></li>
<li>docs.rs: https://docs.rs/cortenforge-burn-dataset</li>
</ul>
<p><strong>Unlocked</strong>
We can now feed the ship real data.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 7 of 9
Progress: [#######–]</p>
<h1 id="we-teach-the-ship-models--training"><a class="header" href="#we-teach-the-ship-models--training">We teach the ship (models + training)</a></h1>
<p><strong>Why</strong>
<code>models</code> defines TinyDet/BigDet. <code>training</code> runs the loop that turns data into checkpoints.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>Dataset batches go in.</li>
<li>Checkpoints come out.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-models -p cortenforge-training</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate page: <a href="10_crates/models/README.html">models</a></li>
<li>Crate page: <a href="10_crates/training/README.html">training</a></li>
<li>docs.rs: https://docs.rs/cortenforge-models and https://docs.rs/cortenforge-training</li>
</ul>
<p><strong>Unlocked</strong>
The ship has a trained brain.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 8 of 9
Progress: [########-]</p>
<h1 id="we-deploy-the-brain-inference"><a class="header" href="#we-deploy-the-brain-inference">We deploy the brain (inference)</a></h1>
<p><strong>Why</strong>
<code>inference</code> loads checkpoints and runs detection live during the sim.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>Training produces checkpoints.</li>
<li>Inference runs them inside the runtime loop.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-inference</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate page: <a href="10_crates/inference/README.html">inference</a></li>
<li>Crate page: <a href="10_crates/vision_runtime/README.html">vision_runtime</a></li>
<li>docs.rs: https://docs.rs/cortenforge-inference</li>
</ul>
<p><strong>Unlocked</strong>
The ship can see and decide in real time.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Step 9 of 9
Progress: [#########]</p>
<h1 id="we-add-mission-control-cortenforge-tools--cli_support"><a class="header" href="#we-add-mission-control-cortenforge-tools--cli_support">We add mission control (cortenforge-tools + cli_support)</a></h1>
<p><strong>Why</strong>
Tooling helps run and observe the pipeline: scheduling, overlays, exports, and common CLI helpers.</p>
<p><strong>How it fits</strong></p>
<ul>
<li><code>cli_support</code> keeps commands consistent.</li>
<li><code>cortenforge-tools</code> holds bins and shared helpers (not published).</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li><code>cargo check -p cortenforge-cli-support -p cortenforge-tools</code></li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate page: <a href="10_crates/cli_support/README.html">cli_support</a></li>
<li>Crate page: <a href="10_crates/cortenforge_tools/README.html">cortenforge-tools</a></li>
<li>docs.rs: https://docs.rs/cortenforge-cli-support (tools are unpublished)</li>
</ul>
<p><strong>Unlocked</strong>
You now have a full, runnable mission stack.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p>Epilogue
Progress: [##########]</p>
<h1 id="we-celebrate-and-choose-the-next-adventure"><a class="header" href="#we-celebrate-and-choose-the-next-adventure">We celebrate and choose the next adventure</a></h1>
<p><strong>Why</strong>
You now have a full mission stack: capture, train, and inference. This is a real app pipeline, not just a demo.</p>
<p><strong>How it fits</strong></p>
<ul>
<li>You can stop here and still have something useful.</li>
<li>When you want depth, follow the links to crate pages and docs.rs.</li>
</ul>
<p><strong>Try it</strong></p>
<ul>
<li>Skim one crate page that felt most exciting.</li>
</ul>
<p><strong>Learn more</strong></p>
<ul>
<li>Crate index: <a href="10_crates/README.html">Crate Overview</a></li>
<li>Workspace map: <a href="#workspace-overview">Workspace Overview</a></li>
</ul>
<p><strong>Next missions (pick one)</strong></p>
<ol>
<li>Make it faster: enable WGPU and compare FPS. (See <a href="10_crates/models/README.html">models</a>, <a href="10_crates/training/README.html">training</a>, <a href="10_crates/inference/README.html">inference</a>.)</li>
<li>Make it safer: add validation thresholds and better logging. (See <a href="10_crates/burn_dataset/README.html">burn_dataset</a>, <a href="10_crates/capture_utils/README.html">capture_utils</a>.)</li>
<li>Make it smarter: swap TinyDet → BigDet and track accuracy. (See <a href="10_crates/models/README.html">models</a>, <a href="10_crates/training/README.html">training</a>.)</li>
<li>Make it operable: add a scheduler + TUI dashboard. (See <a href="10_crates/cortenforge_tools/README.html">cortenforge-tools</a>, <a href="10_crates/cli_support/README.html">cli_support</a>.)</li>
<li>Make it yours: replace the story world with your domain data. (See <a href="10_crates/data_contracts/README.html">data_contracts</a>, <a href="10_crates/vision_core/README.html">vision_core</a>.)</li>
</ol>
<p><strong>Note</strong></p>
<ul>
<li>If something feels stubby, check the crate README for a “Known stubs” callout.</li>
</ul>
<p><strong>Unlocked</strong>
You are ready to build your own missions.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crate-overview"><a class="header" href="#crate-overview">Crate Overview</a></h1>
<p>This chapter is the calm, high-level tour of each crate. Every page stays short and links to docs.rs if you want to go deeper.
If a crate has known stubs or placeholders, its README calls them out under “Known stubs.”</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sim_core"><a class="header" href="#sim_core">sim_core</a></h1>
<p><strong>Why</strong>: The simulation scaffold that everything else plugs into.
<strong>How it fits</strong>: Owns the runtime loop, modes, and hooks for capture/inference.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-sim-core.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_core"><a class="header" href="#vision_core">vision_core</a></h1>
<p><strong>Why</strong>: The shared vision interfaces and data shapes.
<strong>How it fits</strong>: Defines frames, detections, and overlays used across runtime and training.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-vision-core.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_runtime"><a class="header" href="#vision_runtime">vision_runtime</a></h1>
<p><strong>Why</strong>: The runtime glue that runs vision inside the sim.
<strong>How it fits</strong>: Wires capture and inference plugins into the sim loop.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-vision-runtime.</p>
<h2 id="known-stubs"><a class="header" href="#known-stubs">Known stubs</a></h2>
<ul>
<li>Inference can fall back to heuristic detectors when checkpoints are missing or invalid.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data_contracts"><a class="header" href="#data_contracts">data_contracts</a></h1>
<p><strong>Why</strong>: The schemas that keep captures and labels consistent.
<strong>How it fits</strong>: Every recorder and dataset loader depends on these shapes.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-data-contracts.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="capture_utils"><a class="header" href="#capture_utils">capture_utils</a></h1>
<p><strong>Why</strong>: The recorder and capture helpers.
<strong>How it fits</strong>: Writes frames/labels to disk in the data_contracts format.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-capture-utils.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="models"><a class="header" href="#models">models</a></h1>
<p><strong>Why</strong>: The detector architectures (TinyDet/BigDet).
<strong>How it fits</strong>: Used by training to learn and by inference to run.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-models.</p>
<h2 id="known-stubs-1"><a class="header" href="#known-stubs-1">Known stubs</a></h2>
<ul>
<li>Models are intentionally small; treat them as baselines/placeholder capacity for now.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="training"><a class="header" href="#training">training</a></h1>
<p><strong>Why</strong>: The training loop and CLI.
<strong>How it fits</strong>: Consumes datasets and models to produce checkpoints.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-training.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inference"><a class="header" href="#inference">inference</a></h1>
<p><strong>Why</strong>: The runtime detector factory.
<strong>How it fits</strong>: Loads checkpoints and runs detectors in the sim.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-inference.</p>
<h2 id="known-stubs-2"><a class="header" href="#known-stubs-2">Known stubs</a></h2>
<ul>
<li><code>InferencePlugin</code> is a stub that seeds state; real runtime scheduling lives in <code>vision_runtime</code>.</li>
<li><code>InferenceFactory</code> falls back to a heuristic detector if weights are missing or fail to load.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli_support"><a class="header" href="#cli_support">cli_support</a></h1>
<p><strong>Why</strong>: Shared CLI args and helpers.
<strong>How it fits</strong>: Keeps tools and app binaries consistent.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-cli-support.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="burn_dataset"><a class="header" href="#burn_dataset">burn_dataset</a></h1>
<p><strong>Why</strong>: The bridge from captures to training batches.
<strong>How it fits</strong>: Indexes runs and builds Burn-ready tensors for training/inference.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge-burn-dataset.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-tools-shared"><a class="header" href="#cortenforge-tools-shared">cortenforge-tools (shared)</a></h1>
<p>Package name: <code>cortenforge-tools</code>; Rust crate: <code>cortenforge_tools</code>.</p>
<p><strong>Why</strong>: The tooling crate for running, inspecting, and scheduling.
<strong>How it fits</strong>: Hosts bins plus shared helpers; not published.
<strong>Learn more</strong>: Use the pages below; tools are unpublished (no docs.rs).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-umbrella"><a class="header" href="#cortenforge-umbrella">cortenforge (umbrella)</a></h1>
<p><strong>Why</strong>: The umbrella crate that re-exports the stack.
<strong>How it fits</strong>: Lets apps depend on one crate and select features.
<strong>Learn more</strong>: Use the pages below; docs.rs: https://docs.rs/cortenforge.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crate-deep-dives"><a class="header" href="#crate-deep-dives">Crate Deep Dives</a></h1>
<p>Use this chapter when you want detail beyond the calm overview pages. Each crate section goes deeper (public API, lifecycle, module map, and design notes). If you only want the big picture, stay in the Crate Overview chapter.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sim_core-overview"><a class="header" href="#sim_core-overview">sim_core: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem statement</a></h2>
<p>Provide Bevy-based scaffolding for CortenForge apps: building the runtime, configuring mode sets (Common/SimDatagen/Inference), and wiring controls/autopilot and recorder plumbing without embedding detector or domain logic.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<ul>
<li>App builder entrypoints (<code>build_app</code>), Bevy plugins (<code>SimPlugin</code>, <code>SimRuntimePlugin</code>).</li>
<li>Runtime mode sets and hooks (<code>SimHooks</code>, <code>ControlsHook</code>, <code>AutopilotHook</code>).</li>
<li>Recorder types/resources (config/state/motion/world/meta providers) and default sink integration points.</li>
</ul>
<h2 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h2>
<ul>
<li>No detector wiring or vision runtime; those live in <code>vision_runtime</code>/<code>inference</code>.</li>
<li>No domain/world systems; apps supply their own Bevy plugins/systems.</li>
<li>No app-specific tools or schemas.</li>
</ul>
<h2 id="who-should-use-it"><a class="header" href="#who-should-use-it">Who should use it</a></h2>
<ul>
<li>App authors wiring the CortenForge substrate into their own Bevy app (e.g., colon_sim repo).</li>
<li>Contributors extending runtime hooks or recorder scaffolding while keeping the core domain-agnostic.</li>
</ul>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-sim-core</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sim_core-public-api"><a class="header" href="#sim_core-public-api">sim_core: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>SimRunMode</td><td>enum</td><td>Runtime modes (Sim/Datagen/Inference)</td></tr>
<tr><td>SimConfig</td><td>struct</td><td>Configuration for building the sim app (run mode, options)</td></tr>
<tr><td>ModeSet</td><td>enum</td><td>Bevy system sets corresponding to run modes</td></tr>
<tr><td>SimPlugin</td><td>struct</td><td>Bevy plugin registering config/mode sets</td></tr>
<tr><td>SimRuntimePlugin</td><td>struct</td><td>Bevy plugin installing runtime systems</td></tr>
<tr><td>build_app</td><td>fn</td><td>Build a Bevy App with default plugins/sets</td></tr>
<tr><td>SimHooks</td><td>struct</td><td>Holds optional ControlsHook/AutopilotHook callbacks</td></tr>
<tr><td>ControlsHook</td><td>trait</td><td>App-defined control hook interface</td></tr>
<tr><td>AutopilotHook</td><td>trait</td><td>App-defined autopilot hook interface</td></tr>
<tr><td>RecorderMetadataProvider</td><td>trait</td><td>Provides run metadata for recorder</td></tr>
<tr><td>RecorderMetaProvider</td><td>struct</td><td>Wrapper resource implementing provider</td></tr>
<tr><td>BasicRecorderMeta</td><td>struct</td><td>Simple metadata implementation</td></tr>
<tr><td>RecorderSink</td><td>struct</td><td>Wrapper for recorder sink resource</td></tr>
<tr><td>RecorderWorldState</td><td>struct</td><td>World-state snapshot for recorder</td></tr>
<tr><td>RecorderConfig</td><td>struct</td><td>Recorder configuration (paths/options)</td></tr>
<tr><td>RecorderState</td><td>struct</td><td>Recorder state tracking</td></tr>
<tr><td>AutoRecordTimer</td><td>struct</td><td>Timer helper for auto-recording</td></tr>
<tr><td>RecorderMotion</td><td>struct</td><td>Motion info for recorder</td></tr>
<tr><td>ControlParams</td><td>struct</td><td>Input params for controls</td></tr>
<tr><td>ProbeSegment</td><td>struct</td><td>Probe segment type</td></tr>
<tr><td>SegmentSpring</td><td>struct</td><td>Spring parameters for probe segments</td></tr>
<tr><td>AutoStage</td><td>enum</td><td>Autopilot stage</td></tr>
<tr><td>AutoDir</td><td>enum</td><td>Autopilot direction</td></tr>
<tr><td>AutoDrive</td><td>struct</td><td>Autopilot drive parameters</td></tr>
<tr><td>DataRun</td><td>struct</td><td>Datagen run metadata</td></tr>
<tr><td>DatagenInit</td><td>struct</td><td>Datagen init parameters</td></tr>
<tr><td>Flycam</td><td>struct</td><td>Fly camera controller</td></tr>
<tr><td>ProbePovCamera</td><td>struct</td><td>Probe POV camera marker</td></tr>
<tr><td>PovState</td><td>struct</td><td>POV state resource</td></tr>
<tr><td>UiOverlayCamera</td><td>struct</td><td>UI overlay camera marker</td></tr>
<tr><td>setup_camera</td><td>fn</td><td>Bevy system to set up cameras</td></tr>
<tr><td>camera_controller</td><td>fn</td><td>Bevy system for camera control</td></tr>
<tr><td>pov_toggle_system</td><td>fn</td><td>Bevy system to toggle POV</td></tr>
<tr><td>register_runtime_systems</td><td>fn</td><td>Install runtime systems into App</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>autopilot_types, camera, controls, hooks, probe_types, recorder_meta, recorder_types, runtime, prelude</td></tr>
</tbody>
</table>
</div>
<h2 id="links-1"><a class="header" href="#links-1">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/lib.rs</code></li>
<li>Module: <code>sim_core/src/runtime.rs</code></li>
</ul>
<h2 id="usage-map-high-level"><a class="header" href="#usage-map-high-level">Usage map (high level)</a></h2>
<pre class="mermaid">flowchart TB
  build_app --&gt; SimConfig
  build_app --&gt; SimPlugin
  build_app --&gt; SimRuntimePlugin
  build_app --&gt; ModeSet
  build_app --&gt; SimRunMode

  SimRuntimePlugin --&gt; register_runtime_systems
  register_runtime_systems --&gt; ControlsHook
  register_runtime_systems --&gt; AutopilotHook
  register_runtime_systems --&gt; RecorderConfig
  register_runtime_systems --&gt; RecorderState
  register_runtime_systems --&gt; RecorderWorldState
  register_runtime_systems --&gt; AutoRecordTimer
  register_runtime_systems --&gt; setup_camera
  register_runtime_systems --&gt; camera_controller
  register_runtime_systems --&gt; pov_toggle_system

  ControlsHook --&gt; ControlParams
  AutopilotHook --&gt; AutoStage
  AutopilotHook --&gt; AutoDir
  AutopilotHook --&gt; AutoDrive

  RecorderMetaProvider --&gt; RecorderMetadataProvider
  RecorderMetaProvider --&gt; BasicRecorderMeta
  RecorderSink --&gt; RecorderConfig

  ProbeSegment --&gt; SegmentSpring
  PovState --&gt; ProbePovCamera
  PovState --&gt; UiOverlayCamera
</pre>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-sim_core"><a class="header" href="#traits--generics-sim_core">Traits &amp; Generics (sim_core)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits"><a class="header" href="#extensibility-traits">Extensibility traits</a></h2>
<ul>
<li><code>ControlsHook</code>: app provides control systems; required method <code>register(&amp;mut App)</code>. Marker bounds <code>Send + Sync + 'static</code> so it can live in resources and cross threads.</li>
<li><code>AutopilotHook</code>: app provides autopilot systems; same shape/bounds as <code>ControlsHook</code>.</li>
<li><code>RecorderMetadataProvider</code>: app supplies run-level metadata (e.g., polyp seed) for recorders; <code>Send + Sync + 'static</code> for resource safety.</li>
</ul>
<h2 id="glue-types"><a class="header" href="#glue-types">Glue types</a></h2>
<ul>
<li><code>SimHooks</code> (Resource) stores optional boxed <code>ControlsHook</code> / <code>AutopilotHook</code> and invokes <code>apply</code> to register them.</li>
<li><code>RecorderMetaProvider</code> (Resource) wraps a boxed <code>RecorderMetadataProvider</code>.</li>
<li><code>RecorderSink</code> (Resource) holds a boxed <code>vision_core::Recorder</code> (trait object) for output sinks.</li>
</ul>
<h2 id="mermaid-maps"><a class="header" href="#mermaid-maps">Mermaid maps</a></h2>
<h3 id="trait-to-resource-wiring"><a class="header" href="#trait-to-resource-wiring">Trait-to-resource wiring</a></h3>
<pre class="mermaid">flowchart TB
  ControlsHook --&gt; SimHooks
  AutopilotHook --&gt; SimHooks
  RecorderMetadataProvider --&gt; RecorderMetaProvider
  RecorderSink --&gt; vision_core::Recorder

  SimHooks --&gt; App["Bevy App"]
  RecorderMetaProvider --&gt; App
  RecorderSink --&gt; App
</pre>

<h3 id="lifecycle-view"><a class="header" href="#lifecycle-view">Lifecycle view</a></h3>
<pre class="mermaid">sequenceDiagram
  participant App as Bevy App
  participant Caller as App code
  participant SimHooks as SimHooks (Resource)
  participant C as ControlsHook
  participant A as AutopilotHook
  participant R as RecorderMetaProvider

  Caller-&gt;&gt;SimHooks: set optional C/A
  Caller-&gt;&gt;R: set provider
  Caller-&gt;&gt;App: insert_resource(SimHooks, R)
  Caller-&gt;&gt;SimHooks: apply(&amp;mut App)
  SimHooks-&gt;&gt;C: register(&amp;mut App)
  SimHooks-&gt;&gt;A: register(&amp;mut App)
</pre>

<h2 id="generics-and-bounds"><a class="header" href="#generics-and-bounds">Generics and bounds</a></h2>
<ul>
<li>No generic types in this crate; extensibility is via trait objects with <code>Send + Sync + 'static</code> to satisfy Bevy resource requirements.</li>
<li>Hooks require <code>&amp;mut App</code> to register systems/plugins, keeping ownership straightforward and avoiding lifetime gymnastics.</li>
</ul>
<h2 id="links-2"><a class="header" href="#links-2">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/hooks.rs</code></li>
</ul>
<h2 id="design-notes"><a class="header" href="#design-notes">Design notes</a></h2>
<ul>
<li>Trait-object approach keeps app integration simple (no generics on <code>App</code>), at the cost of dynamic dispatch; fine for setup-time hooks.</li>
<li>If more metadata fields are needed, extend <code>RecorderMetadataProvider</code> instead of threading ad-hoc resources.</li>
<li>Keep hook registration idempotent; current design assumes the caller manages not to double-register.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sim_core-module-map"><a class="header" href="#sim_core-module-map">sim_core: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>autopilot_types</code>: Autopilot-related types (AutoStage/AutoDir/AutoDrive/DataRun/DatagenInit).</li>
<li><code>camera</code>: Camera resources/systems and setup/controllers.
<ul>
<li>Includes Flycam, ProbePovCamera, UiOverlayCamera.</li>
</ul>
</li>
<li><code>controls</code>: Control parameter structs and related utilities.</li>
<li><code>hooks</code>: Hook traits (ControlsHook, AutopilotHook) and SimHooks container.</li>
<li><code>probe_types</code>: Probe segment types (ProbeSegment, SegmentSpring).</li>
<li><code>recorder_meta</code>: Recorder metadata provider trait and wrappers.
<ul>
<li>Types: RecorderMetadataProvider, RecorderMetaProvider, BasicRecorderMeta, RecorderSink, RecorderWorldState.</li>
</ul>
</li>
<li><code>recorder_types</code>: Recorder config/state/motion types.
<ul>
<li>Types: RecorderConfig, RecorderState, AutoRecordTimer, RecorderMotion.</li>
</ul>
</li>
<li><code>runtime</code>: Runtime plugin and system registration (SimRuntimePlugin, register_runtime_systems).</li>
<li><code>prelude</code>: Convenience re-exports for downstream users.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>hooks/config feed runtime.</li>
<li>recorder_meta/types used by runtime and apps.</li>
<li>camera systems integrate with runtime.</li>
<li>autopilot/control types used by hooks/apps.</li>
</ul>
<h2 id="mermaid-maps-1"><a class="header" href="#mermaid-maps-1">Mermaid maps</a></h2>
<h3 id="module-dependency-graph-high-level"><a class="header" href="#module-dependency-graph-high-level">Module dependency graph (high level)</a></h3>
<pre class="mermaid">flowchart TB
  autopilot_types --&gt; hooks
  controls --&gt; hooks
  hooks --&gt; runtime
  recorder_meta --&gt; runtime
  recorder_types --&gt; runtime
  camera --&gt; runtime
  probe_types --&gt; runtime

  hooks --&gt; prelude
  recorder_meta --&gt; prelude
  recorder_types --&gt; prelude
  autopilot_types --&gt; prelude
  controls --&gt; prelude
  camera --&gt; prelude
  probe_types --&gt; prelude
  runtime --&gt; prelude
</pre>

<h3 id="public-surface-grouping"><a class="header" href="#public-surface-grouping">Public surface grouping</a></h3>
<pre class="mermaid">flowchart LR
  subgraph sim_core
    subgraph modules
      autopilot_types
      camera
      controls
      hooks
      probe_types
      recorder_meta
      recorder_types
      runtime
    end
    prelude
  end

  prelude --&gt; modules
</pre>

<h2 id="links-3"><a class="header" href="#links-3">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sim_core-lifecycle"><a class="header" href="#sim_core-lifecycle">sim_core: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage"><a class="header" href="#typical-usage">Typical usage</a></h2>
<ol>
<li>Construct config and hooks:
<pre><code class="language-rust ignore">let config = SimConfig::default();
let hooks = SimHooks::default() // optional ControlsHook/AutopilotHook
    .with_controls(Box::new(MyControls))
    .with_autopilot(Box::new(MyAutopilot));</code></pre>
</li>
<li>Build the Bevy app and insert hooks/recorder meta/world state:
<pre><code class="language-rust ignore">let mut app = sim_core::build_app(config);
app.insert_resource(hooks);
app.insert_resource(RecorderMetaProvider { provider: Box::new(MyMeta {}) });
app.insert_resource(RecorderWorldState::default());</code></pre>
</li>
<li>Add plugins and systems:
<pre><code class="language-rust ignore">app.add_plugins((SimPlugin, SimRuntimePlugin));
app.add_systems(Update, my_world_state_updater.in_set(ModeSet::Common));</code></pre>
</li>
<li>Run the app:
<pre><code class="language-rust ignore">app.run();</code></pre>
</li>
</ol>
<h2 id="execution-flow"><a class="header" href="#execution-flow">Execution flow</a></h2>
<ul>
<li><code>build_app</code> seeds Bevy with default plugins, Rapier, mode sets.</li>
<li><code>SimPlugin</code> registers config and system sets (Common/SimDatagen/Inference).</li>
<li><code>SimRuntimePlugin</code> installs runtime systems.</li>
<li>Hooks (controls/autopilot) are invoked based on mode sets.</li>
<li>Recorder resources collect meta/world state; sink provided by capture_utils or app.</li>
</ul>
<h2 id="mermaid-maps-2"><a class="header" href="#mermaid-maps-2">Mermaid maps</a></h2>
<h3 id="setup-to-run-high-level"><a class="header" href="#setup-to-run-high-level">Setup to run (high level)</a></h3>
<pre class="mermaid">flowchart TB
  A["Construct SimConfig and SimHooks"] --&gt; B["build_app with config"]
  B --&gt; C["Insert resources: hooks, meta provider, world state"]
  C --&gt; D["Add SimPlugin and SimRuntimePlugin"]
  D --&gt; E["Add app systems"]
  E --&gt; F["app.run"]
</pre>

<h3 id="runtime-execution-flow"><a class="header" href="#runtime-execution-flow">Runtime execution flow</a></h3>
<pre class="mermaid">sequenceDiagram
  participant App as Bevy App
  participant SimP as SimPlugin
  participant RunP as SimRuntimePlugin
  participant Hooks as SimHooks
  participant Rec as Recorder resources

  App-&gt;&gt;SimP: register config + mode sets
  App-&gt;&gt;RunP: install runtime systems
  App-&gt;&gt;Hooks: apply controls/autopilot hooks
  App-&gt;&gt;Rec: update meta + world state
</pre>

<h2 id="shutdowncleanup"><a class="header" href="#shutdowncleanup">Shutdown/cleanup</a></h2>
<ul>
<li>Standard Bevy app lifecycle; no special shutdown beyond Bevy teardown.</li>
</ul>
<h2 id="links-4"><a class="header" href="#links-4">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/lib.rs</code></li>
<li>Module: <code>sim_core/src/runtime.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-sim_core"><a class="header" href="#error-model-sim_core">Error Model (sim_core)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined"><a class="header" href="#errors-defined">Errors defined</a></h2>
<ul>
<li>None. sim_core does not define custom error types; it provides Bevy resources/hooks and relies on downstream crates for IO/inference errors.</li>
</ul>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<ul>
<li>Hook application (<code>SimHooks::apply</code>) and recorder metadata use trait objects without fallible paths.</li>
<li>Panic risk: none beyond standard library panics if poisoned mutexes or similar were introduced elsewhere; current code is straightforward.</li>
</ul>
<h2 id="recoverability"><a class="header" href="#recoverability">Recoverability</a></h2>
<ul>
<li>All operations are setup-time Bevy registration; no runtime fallible APIs exposed.</li>
</ul>
<h2 id="ergonomics"><a class="header" href="#ergonomics">Ergonomics</a></h2>
<ul>
<li>Simplicity: no Result-heavy flows. Consumers should surface their own errors when implementing hooks or recorders.</li>
<li>If new fallible initialization is added (e.g., asset loading), prefer returning <code>bevy::app::AppError</code> or custom error enums to keep ergonomics consistent across the workspace.</li>
</ul>
<h2 id="mermaid-map"><a class="header" href="#mermaid-map">Mermaid map</a></h2>
<h3 id="error-surface-current"><a class="header" href="#error-surface-current">Error surface (current)</a></h3>
<pre class="mermaid">flowchart TB
  SimCore["sim_core API"] --&gt; Setup["Setup time registration"]
  Setup --&gt; NoErrors["No custom error types"]
  Hooks["Hooks and recorders"] --&gt; Downstream["Downstream errors"]
  Downstream --&gt; AppErr["App specific Result or AppError"]
</pre>

<h3 id="error-surface-if-fallible-init-is-added"><a class="header" href="#error-surface-if-fallible-init-is-added">Error surface (if fallible init is added)</a></h3>
<p>If sim_core introduces fallible initialization (asset loading, external services), this is the recommended flow.</p>
<pre class="mermaid">flowchart TB
  Init["sim_core init"] --&gt; Result["Result&lt;T, AppError or custom enum&gt;"]
  Result --&gt; Caller["Downstream caller"]
  Caller --&gt; Handle["Handle or propagate"]
</pre>

<h2 id="links-5"><a class="header" href="#links-5">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-sim_core"><a class="header" href="#ownership--concurrency-sim_core">Ownership &amp; Concurrency (sim_core)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model"><a class="header" href="#ownership-model">Ownership model</a></h2>
<ul>
<li>Resources (<code>SimHooks</code>, <code>RecorderMetaProvider</code>, <code>RecorderSink</code>, <code>RecorderWorldState</code>) are stored as Bevy resources with owned boxed trait objects.</li>
<li>Hooks are applied by borrowing <code>&amp;mut App</code>; no shared references persist beyond setup.</li>
</ul>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<ul>
<li>No explicit threading or async. Trait objects are bounded by <code>Send + Sync + 'static</code> to be Bevy-resource safe if Bevy uses multi-threaded schedules.</li>
<li>Recorder sink and metadata provider are boxed trait objects; implementations must be thread-safe due to bounds.</li>
</ul>
<h2 id="borrowing-boundaries"><a class="header" href="#borrowing-boundaries">Borrowing boundaries</a></h2>
<ul>
<li>Hook registration occurs during setup; lifetimes are <code>'static</code> via boxed trait objects. No non-’static borrows are stored.</li>
</ul>
<h2 id="async-boundaries"><a class="header" href="#async-boundaries">Async boundaries</a></h2>
<ul>
<li>None in this crate; async behavior lives in higher layers (vision_runtime).</li>
</ul>
<h2 id="risks--notes"><a class="header" href="#risks--notes">Risks / notes</a></h2>
<ul>
<li>Minimal; ensure custom hook/recorder implementations honor <code>Send + Sync</code> and avoid interior mutability pitfalls beyond what Bevy expects.</li>
</ul>
<h2 id="mermaid-maps-3"><a class="header" href="#mermaid-maps-3">Mermaid maps</a></h2>
<h3 id="ownership-flow-resources"><a class="header" href="#ownership-flow-resources">Ownership flow (resources)</a></h3>
<pre class="mermaid">flowchart TB
  App["Bevy App"] --&gt; Resources["Resources owned by App"]
  Resources --&gt; SimHooks
  Resources --&gt; RecorderMetaProvider
  Resources --&gt; RecorderSink
  Resources --&gt; RecorderWorldState

  SimHooks --&gt; ControlsHook
  SimHooks --&gt; AutopilotHook
  RecorderMetaProvider --&gt; RecorderMetadataProvider
  RecorderSink --&gt; RecorderTrait["vision_core::Recorder"]
</pre>

<h3 id="concurrency-boundaries"><a class="header" href="#concurrency-boundaries">Concurrency boundaries</a></h3>
<pre class="mermaid">flowchart LR
  Hooks["Hook trait objects"] --&gt; Bounds["Send + Sync + 'static"]
  Meta["Metadata provider"] --&gt; Bounds
  Sink["Recorder sink"] --&gt; Bounds
  Bounds --&gt; Scheduler["Bevy multi-threaded schedule"]
</pre>

<h3 id="setup-time-borrowing"><a class="header" href="#setup-time-borrowing">Setup-time borrowing</a></h3>
<pre class="mermaid">sequenceDiagram
  participant App as Bevy App
  participant RunP as SimRuntimePlugin
  participant Hooks as SimHooks
  participant C as ControlsHook
  participant A as AutopilotHook
  participant Rec as Recorder resources

  App-&gt;&gt;RunP: add plugin and systems
  App-&gt;&gt;Rec: insert recorder resources
  App-&gt;&gt;Hooks: apply(&amp;mut App)
  Hooks-&gt;&gt;C: register(&amp;mut App)
  Hooks-&gt;&gt;A: register(&amp;mut App)
  App--&gt;&gt;Hooks: release mutable borrow
</pre>

<h2 id="links-6"><a class="header" href="#links-6">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/hooks.rs</code></li>
<li>Module: <code>sim_core/src/runtime.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-sim_core"><a class="header" href="#performance-notes-sim_core">Performance Notes (sim_core)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths"><a class="header" href="#hot-paths">Hot paths</a></h2>
<ul>
<li>None in this crate; it provides Bevy scaffolding, hooks, and recorder metadata resources. No heavy per-frame computation here.</li>
</ul>
<h2 id="allocation-patterns"><a class="header" href="#allocation-patterns">Allocation patterns</a></h2>
<ul>
<li>Minimal allocations for boxed trait objects (<code>SimHooks</code>, <code>RecorderMetaProvider</code>, <code>RecorderSink</code>).</li>
<li>No per-frame allocations within sim_core itself.</li>
</ul>
<h2 id="trait-objects"><a class="header" href="#trait-objects">Trait objects</a></h2>
<ul>
<li>Hooks and recorder providers are trait objects; dynamic dispatch cost is negligible and occurs during setup or recorder use.</li>
</ul>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<ul>
<li>Performance-sensitive work (simulation systems, recorders) lives in downstream crates/apps; sim_core’s overhead is negligible compared to Bevy runtime.</li>
</ul>
<h2 id="improvements"><a class="header" href="#improvements">Improvements</a></h2>
<ul>
<li>None needed at this layer. Keep hook invocation minimal and avoid duplicate registration to keep startup cost low.</li>
</ul>
<h2 id="mermaid-maps-4"><a class="header" href="#mermaid-maps-4">Mermaid maps</a></h2>
<h3 id="performance-surface"><a class="header" href="#performance-surface">Performance surface</a></h3>
<pre class="mermaid">flowchart TB
  SimCore["sim_core scaffolding"] --&gt; Setup["Setup time only"]
  Setup --&gt; LowCost["Negligible runtime cost"]
  Downstream["Downstream systems and recorders"] --&gt; HotPath["Per frame work"]
  HotPath --&gt; Budget["Primary perf budget"]
</pre>

<h3 id="allocation-timing"><a class="header" href="#allocation-timing">Allocation timing</a></h3>
<pre class="mermaid">flowchart LR
  Startup["Startup"] --&gt; Boxes["Boxed trait objects allocated"]
  Boxes --&gt; Idle["No per frame allocations in sim_core"]
  Runtime["Runtime"] --&gt; DownstreamAlloc["Allocations in downstream crates"]
</pre>

<h2 id="links-7"><a class="header" href="#links-7">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-sim_core"><a class="header" href="#examples-sim_core">Examples (sim_core)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-register-custom-hooks-controls--autopilot"><a class="header" href="#1-register-custom-hooks-controls--autopilot">1) Register custom hooks (controls + autopilot)</a></h2>
<pre><code class="language-rust ignore">use bevy::prelude::*;
use sim_core::hooks::{AutopilotHook, ControlsHook, SimHooks};

struct MyControls;
impl ControlsHook for MyControls {
    fn register(&amp;self, app: &amp;mut App) {
        app.add_systems(Update, |time: Res&lt;Time&gt;| {
            // drive controls/resources here
            info!("tick {:?}", time.elapsed_seconds_wrapped());
        });
    }
}

struct MyAutopilot;
impl AutopilotHook for MyAutopilot {
    fn register(&amp;self, app: &amp;mut App) {
        app.add_systems(Update, |mut commands: Commands| {
            // spawn autopilot systems/entities
            commands.spawn_empty();
        });
    }
}

fn main() {
    let mut app = App::new();
    app.insert_resource(SimHooks {
        controls: Some(Box::new(MyControls)),
        autopilot: Some(Box::new(MyAutopilot)),
    });
    // later: call SimHooks::apply(&amp;mut app) in your setup stage
}</code></pre>
<h2 id="2-provide-recorder-metadata--sink"><a class="header" href="#2-provide-recorder-metadata--sink">2) Provide recorder metadata + sink</a></h2>
<pre><code class="language-rust ignore">use bevy::prelude::*;
use sim_core::recorder_meta::{BasicRecorderMeta, RecorderMetaProvider, RecorderMetadataProvider, RecorderSink};

fn setup_recorder(mut commands: Commands) {
    // Provide run-level metadata (e.g., seed)
    commands.insert_resource(RecorderMetaProvider {
        provider: Box::new(BasicRecorderMeta { seed: 1234 }),
    });

    // Provide a recorder sink (here just a placeholder that does nothing)
    struct NullRecorder;
    impl vision_core::prelude::Recorder for NullRecorder {
        fn record(&amp;mut self, _record: &amp;vision_core::prelude::FrameRecord) -&gt; std::io::Result&lt;()&gt; {
            Ok(())
        }
    }
    commands.insert_resource(RecorderSink {
        writer: Some(Box::new(NullRecorder)),
    });
}</code></pre>
<h2 id="3-wire-world-state-for-recorder-triggers"><a class="header" href="#3-wire-world-state-for-recorder-triggers">3) Wire world state for recorder triggers</a></h2>
<pre><code class="language-rust ignore">use bevy::prelude::*;
use sim_core::recorder_meta::RecorderWorldState;

fn update_world_state(mut state: ResMut&lt;RecorderWorldState&gt;) {
    state.head_z = Some(1.2);
    if state.head_z.unwrap() &gt; 2.0 {
        state.stop_flag = true; // could be read by recorder triggers
    }
}</code></pre>
<h2 id="mermaid-maps-5"><a class="header" href="#mermaid-maps-5">Mermaid maps</a></h2>
<h3 id="examples-overview"><a class="header" href="#examples-overview">Examples overview</a></h3>
<pre class="mermaid">flowchart TB
  Hooks["ControlsHook + AutopilotHook"] --&gt; App["Bevy App setup"]
  App --&gt; Runtime["SimRuntimePlugin systems"]
  Recorder["RecorderMetaProvider + RecorderSink"] --&gt; Runtime
  World["RecorderWorldState"] --&gt; Runtime
</pre>

<h3 id="recorder-pipeline"><a class="header" href="#recorder-pipeline">Recorder pipeline</a></h3>
<pre class="mermaid">flowchart LR
  Meta["RecorderMetaProvider"] --&gt; Rec["RecorderSink"]
  World["RecorderWorldState"] --&gt; Rec
  Rec --&gt; Output["recorded frames"]
</pre>

<h2 id="links-8"><a class="header" href="#links-8">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/hooks.rs</code></li>
<li>Source: <code>sim_core/src/recorder_meta.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-sim_core"><a class="header" href="#design-review-sim_core">Design Review (sim_core)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid"><a class="header" href="#whats-solid">What’s solid</a></h2>
<ul>
<li>Very small surface: Bevy scaffolding + hook traits make it easy for an app to bolt on controls/autopilot without touching core.</li>
<li>Recorder metadata/sink abstractions are simple trait objects with clear responsibilities.</li>
<li>No hidden side effects; resources are explicit.</li>
</ul>
<h2 id="risks--gaps"><a class="header" href="#risks--gaps">Risks / gaps</a></h2>
<ul>
<li>Recorder metadata is fixed to a single seed field; if more metadata is needed, the trait will need to evolve (breaking change).</li>
<li>Hook registration relies on caller discipline (no duplicate registration, ordering); no guards or idempotence.</li>
<li>Recorder sink is a single boxed writer; no built-in fan-out or composition.</li>
</ul>
<h2 id="refactor-ideas"><a class="header" href="#refactor-ideas">Refactor ideas</a></h2>
<ul>
<li>Make <code>RecorderMetadataProvider</code> extensible (e.g., key/value map or versioned struct) to avoid frequent breaking changes.</li>
<li>Add optional idempotent registration helpers (e.g., sets to avoid double-adding systems).</li>
<li>Provide a small fan-out recorder combinator (e.g., <code>Vec&lt;Box&lt;Recorder&gt;&gt;</code>) for multi-sink use cases.</li>
</ul>
<h2 id="links-9"><a class="header" href="#links-9">Links</a></h2>
<ul>
<li>Source: <code>sim_core/src/recorder_meta.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_core-overview"><a class="header" href="#vision_core-overview">vision_core: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-1"><a class="header" href="#problem-statement-1">Problem statement</a></h2>
<p>Provide a detector/capture data model and overlay math that are engine-agnostic, forming the core vision interfaces for the stack.</p>
<h2 id="scope-1"><a class="header" href="#scope-1">Scope</a></h2>
<ul>
<li>Data types: frames, frame records, labels, detection results.</li>
<li>Traits/interfaces: Detector/Recorder abstractions.</li>
<li>Overlay utilities (e.g., draw_rect) and capture limits.</li>
<li>Interfaces/overlay are runtime-agnostic; capture resources use Bevy types for integration.</li>
</ul>
<h2 id="non-goals-1"><a class="header" href="#non-goals-1">Non-goals</a></h2>
<ul>
<li>No Bevy plugins or runtime scheduling (handled by vision_runtime).</li>
<li>No detector implementations or model loading (handled by inference/models).</li>
<li>No recorder sinks (handled by capture_utils/apps).</li>
</ul>
<h2 id="who-should-use-it-1"><a class="header" href="#who-should-use-it-1">Who should use it</a></h2>
<ul>
<li>Runtime/plugins (vision_runtime) needing the shared vision interfaces and overlay math.</li>
<li>Tools and sinks that operate on frame/label data structures.</li>
<li>Contributors defining detectors/recorders or working on overlay logic.</li>
</ul>
<h2 id="links-10"><a class="header" href="#links-10">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/lib.rs</code></li>
<li>Module: <code>vision_core/src/interfaces.rs</code></li>
<li>Module: <code>vision_core/src/overlay.rs</code></li>
<li>Module: <code>vision_core/src/capture.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-vision-core</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_core-public-api"><a class="header" href="#vision_core-public-api">vision_core: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Frame</td><td>struct</td><td>Represents a captured frame</td></tr>
<tr><td>FrameRecord&lt;’a&gt;</td><td>struct</td><td>Frame plus associated labels/metadata</td></tr>
<tr><td>DetectionResult</td><td>struct</td><td>Detector output (labels/confidence)</td></tr>
<tr><td>Label</td><td>struct</td><td>Bounding box/class metadata</td></tr>
<tr><td>FrameSource</td><td>trait</td><td>Source that can produce frames</td></tr>
<tr><td>Detector</td><td>trait</td><td>Detector interface consuming frames and producing results</td></tr>
<tr><td>Recorder</td><td>trait</td><td>Recorder interface for frames/labels</td></tr>
<tr><td>BurnDetectorFactory</td><td>trait</td><td>Factory for Burn-backed detectors</td></tr>
<tr><td>CaptureLimit</td><td>struct</td><td>Limits for capture (frame counts, etc.)</td></tr>
<tr><td>FrontCamera</td><td>struct</td><td>Marker for front camera</td></tr>
<tr><td>FrontCaptureCamera</td><td>struct</td><td>Marker for capture camera</td></tr>
<tr><td>FrontCaptureTarget</td><td>struct</td><td>Capture render target resource</td></tr>
<tr><td>FrontCaptureReadback</td><td>struct</td><td>Capture readback resource</td></tr>
<tr><td>normalize_box</td><td>fn</td><td>Normalize bbox coords to pixel space</td></tr>
<tr><td>draw_rect</td><td>fn</td><td>Draw rectangle onto RGBA image</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>capture, interfaces, overlay, prelude</td></tr>
</tbody>
</table>
</div>
<h2 id="links-11"><a class="header" href="#links-11">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/lib.rs</code></li>
<li>Module: <code>vision_core/src/interfaces.rs</code></li>
<li>Module: <code>vision_core/src/overlay.rs</code></li>
<li>Module: <code>vision_core/src/capture.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-vision-core</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-vision_core"><a class="header" href="#traits--generics-vision_core">Traits &amp; Generics (vision_core)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-1"><a class="header" href="#extensibility-traits-1">Extensibility traits</a></h2>
<ul>
<li><code>FrameSource</code>: pull next frame from camera/files/generator. Return <code>Option&lt;Frame&gt;</code>.</li>
<li><code>Detector</code>: run inference over a <code>Frame</code>, returning <code>DetectionResult</code>; optional <code>set_thresholds</code> hook.</li>
<li><code>Recorder</code>: persist <code>FrameRecord</code> (frame + labels + metadata) to a sink (disk/stream/etc.).</li>
<li><code>BurnDetectorFactory</code>: feature-flagged hook for constructing a Burn-backed <code>Detector</code> from a checkpoint path (<code>type Detector: Detector</code> associated type).</li>
</ul>
<h2 id="glue-types-1"><a class="header" href="#glue-types-1">Glue types</a></h2>
<ul>
<li>Data structs (<code>Frame</code>, <code>DetectionResult</code>, <code>Label</code>, <code>FrameRecord</code>) define the shared contract between runtime, detectors, and recorders.</li>
<li>No internal traits beyond the public interfaces above.</li>
</ul>
<h2 id="generics-and-bounds-1"><a class="header" href="#generics-and-bounds-1">Generics and bounds</a></h2>
<ul>
<li>Traits are object-safe (no generic methods), enabling trait objects for detectors/recorders/frame sources.</li>
<li><code>BurnDetectorFactory</code> uses an associated type constrained by <code>Detector</code> so consumers can select concrete detector types while keeping API simple.</li>
<li>No lifetime gymnastics; <code>FrameRecord</code> uses a label slice borrow to avoid copies in recorder implementations.</li>
</ul>
<h2 id="design-notes-1"><a class="header" href="#design-notes-1">Design notes</a></h2>
<ul>
<li>Interface set is intentionally minimal to keep runtime embedding straightforward (Bevy plugins, CLI tools).</li>
<li>Trait-object friendliness allows swapping implementations at runtime (heuristic vs. Burn, file vs. camera source, JSON vs. binary recorder).</li>
<li>If adding async paths, consider separate async traits or adapters to keep current sync trait objects intact.</li>
</ul>
<h2 id="links-12"><a class="header" href="#links-12">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/interfaces.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_core-module-map"><a class="header" href="#vision_core-module-map">vision_core: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>capture</code>: Capture-related resources/types (CaptureLimit, FrontCamera markers, FrontCaptureTarget/Readback).</li>
<li><code>interfaces</code>: Core vision types and traits.
<ul>
<li>Types: Frame, FrameRecord, DetectionResult, Label.</li>
<li>Traits: Detector, Recorder, FrameSource, BurnDetectorFactory.</li>
</ul>
</li>
<li><code>overlay</code>: Overlay helpers (normalize_box, draw_rect) and related utilities.</li>
<li><code>prelude</code>: Convenience re-exports for downstream users.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>interfaces define the shared contracts.</li>
<li>capture provides resources used by runtime.</li>
<li>overlay operates on data from interfaces.</li>
<li>prelude re-exports common items.</li>
</ul>
<h2 id="links-13"><a class="header" href="#links-13">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_core-lifecycle"><a class="header" href="#vision_core-lifecycle">vision_core: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-1"><a class="header" href="#typical-usage-1">Typical usage</a></h2>
<ul>
<li>Implement a detector:
<pre><code class="language-rust ignore">struct MyDet;
impl Detector for MyDet {
    fn detect(&amp;mut self, frame: &amp;Frame) -&gt; DetectionResult { /* ... */ }
}</code></pre>
</li>
<li>Use recorder/detector traits in runtime/tools; construct <code>FrameRecord</code> and emit <code>Label</code>/<code>DetectionResult</code> as needed.</li>
<li>Apply overlay helpers when rendering labels:
<pre><code class="language-rust ignore">if let Some(bbox_px) = normalize_box(bbox_norm, dims) {
    draw_rect(&amp;mut image, bbox_px, color, thickness);
}</code></pre>
</li>
</ul>
<h2 id="execution-flow-1"><a class="header" href="#execution-flow-1">Execution flow</a></h2>
<ul>
<li>Consumers (vision_runtime/tools) create <code>Frame</code>/<code>FrameRecord</code> instances.</li>
<li>Detectors implementing <code>Detector</code> consume frames and produce <code>DetectionResult</code>.</li>
<li>Recorders implementing <code>Recorder</code> ingest frames/labels per schema.</li>
<li>Overlay helpers render bounding boxes to images.</li>
</ul>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>Interfaces/overlay are runtime-agnostic; capture resources use Bevy types but have no lifecycle of their own. Initialization/teardown is managed by consumers.</li>
</ul>
<h2 id="links-14"><a class="header" href="#links-14">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/interfaces.rs</code></li>
<li>Source: <code>vision_core/src/overlay.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-vision_core"><a class="header" href="#error-model-vision_core">Error Model (vision_core)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-1"><a class="header" href="#errors-defined-1">Errors defined</a></h2>
<ul>
<li>None directly; error handling is delegated to trait methods’ return types:
<ul>
<li><code>Detector::detect</code> returns a <code>DetectionResult</code> (not fallible).</li>
<li><code>Recorder::record</code> returns <code>std::io::Result&lt;()&gt;</code>.</li>
<li><code>BurnDetectorFactory::load</code> returns <code>anyhow::Result&lt;Self::Detector&gt;</code>.</li>
</ul>
</li>
</ul>
<h2 id="patterns-1"><a class="header" href="#patterns-1">Patterns</a></h2>
<ul>
<li>Detectors are expected to be infallible at the API surface; recoverable errors should be embedded in the <code>DetectionResult</code> (e.g., fallback flags) or logged internally.</li>
<li>Recorders surface IO errors directly via <code>std::io::Error</code>.</li>
<li>Burn factory uses <code>anyhow::Result</code> to aggregate load/config errors without defining a crate-specific error type.</li>
</ul>
<h2 id="recoverability-1"><a class="header" href="#recoverability-1">Recoverability</a></h2>
<ul>
<li>Recording failures are caller-visible (<code>io::Error</code>); runtime should decide whether to retry/skip.</li>
<li>Burn detector loading is caller-visible; consumers should fall back (as <code>inference</code> and <code>vision_runtime</code> do) when load fails.</li>
</ul>
<h2 id="ergonomics-1"><a class="header" href="#ergonomics-1">Ergonomics</a></h2>
<ul>
<li>Keeping <code>DetectionResult</code> infallible simplifies detector implementations but shifts error signaling to logging/fallback modes.</li>
<li><code>anyhow</code> in factory allows rich context; consider a typed error if multiple backends are added and need programmatic handling.</li>
</ul>
<h2 id="links-15"><a class="header" href="#links-15">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/interfaces.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-vision_core"><a class="header" href="#ownership--concurrency-vision_core">Ownership &amp; Concurrency (vision_core)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-1"><a class="header" href="#ownership-model-1">Ownership model</a></h2>
<ul>
<li>Trait objects (<code>Detector</code>, <code>Recorder</code>, <code>FrameSource</code>) are expected to be owned by callers; the crate only defines the interfaces and data structs (<code>Frame</code>, <code>DetectionResult</code>, etc.).</li>
<li><code>FrameRecord</code> borrows labels slice (<code>&amp;[Label]</code>) to avoid copies when recording.</li>
</ul>
<h2 id="concurrency-1"><a class="header" href="#concurrency-1">Concurrency</a></h2>
<ul>
<li>Traits are object-safe but have no <code>Send/Sync</code> bounds at the interface level; callers decide whether to enforce thread safety. Downstream crates (vision_runtime/inference) wrap detectors/recorders in <code>Send + Sync</code>.</li>
<li>No internal concurrency; interfaces are synchronous.</li>
</ul>
<h2 id="borrowing-boundaries-1"><a class="header" href="#borrowing-boundaries-1">Borrowing boundaries</a></h2>
<ul>
<li><code>FrameRecord</code> ties the lifetime of labels to the record call; recorder implementers must not store references beyond the call unless they clone.</li>
</ul>
<h2 id="async-boundaries-1"><a class="header" href="#async-boundaries-1">Async boundaries</a></h2>
<ul>
<li>None; all APIs are synchronous. Async execution (e.g., inference tasks) is layered on elsewhere.</li>
</ul>
<h2 id="risks--notes-1"><a class="header" href="#risks--notes-1">Risks / notes</a></h2>
<ul>
<li>Lack of <code>Send + Sync</code> bounds keeps the core interfaces flexible but requires downstream crates to add bounds when used across threads (as they do).</li>
</ul>
<h2 id="links-16"><a class="header" href="#links-16">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/interfaces.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-vision_core"><a class="header" href="#performance-notes-vision_core">Performance Notes (vision_core)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-1"><a class="header" href="#hot-paths-1">Hot paths</a></h2>
<ul>
<li>None; this crate defines interfaces and lightweight data structs. No compute-heavy logic.</li>
</ul>
<h2 id="allocation-patterns-1"><a class="header" href="#allocation-patterns-1">Allocation patterns</a></h2>
<ul>
<li><code>DetectionResult</code> and <code>Frame</code> own vectors (<code>boxes</code>, <code>scores</code>, optional <code>rgba</code>), allocated by implementers.</li>
<li>No caching or pooling implemented here.</li>
</ul>
<h2 id="trait-objects-1"><a class="header" href="#trait-objects-1">Trait objects</a></h2>
<ul>
<li>Traits are object-safe; dynamic dispatch cost is minimal. Implementers decide how to manage allocations/caching.</li>
</ul>
<h2 id="assumptions-1"><a class="header" href="#assumptions-1">Assumptions</a></h2>
<ul>
<li>Performance is dominated by detector/recorder implementations in downstream crates; vision_core adds negligible overhead.</li>
</ul>
<h2 id="improvements-1"><a class="header" href="#improvements-1">Improvements</a></h2>
<ul>
<li>If allocations in <code>DetectionResult</code> become hot, implementers can reuse buffers; interfaces permit that (caller-owned structs).</li>
</ul>
<h2 id="links-17"><a class="header" href="#links-17">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/interfaces.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-vision_core"><a class="header" href="#examples-vision_core">Examples (vision_core)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-implement-a-simple-detector"><a class="header" href="#1-implement-a-simple-detector">1) Implement a simple detector</a></h2>
<pre><code class="language-rust ignore">use vision_core::interfaces::{Detector, Frame, DetectionResult};

struct ThresholdDetector {
    threshold: f32,
}

impl Detector for ThresholdDetector {
    fn detect(&amp;mut self, frame: &amp;Frame) -&gt; DetectionResult {
        // Toy heuristic: positive if frame id is even
        let positive = frame.id % 2 == 0;
        DetectionResult {
            frame_id: frame.id,
            positive,
            confidence: if positive { self.threshold } else { 1.0 - self.threshold },
            boxes: Vec::new(),
            scores: Vec::new(),
        }
    }
}</code></pre>
<h2 id="2-implement-a-recorder"><a class="header" href="#2-implement-a-recorder">2) Implement a recorder</a></h2>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::Write;
use vision_core::interfaces::{FrameRecord, Recorder};

struct FileRecorder {
    out: File,
}

impl Recorder for FileRecorder {
    fn record(&amp;mut self, record: &amp;FrameRecord) -&gt; std::io::Result&lt;()&gt; {
        writeln!(
            self.out,
            "frame={} labels={} active={}",
            record.frame.id,
            record.labels.len(),
            record.camera_active
        )
    }
}</code></pre>
<h2 id="3-implement-a-frame-source"><a class="header" href="#3-implement-a-frame-source">3) Implement a frame source</a></h2>
<pre><code class="language-rust ignore">use vision_core::interfaces::{Frame, FrameSource};

struct StaticFrameSource {
    frames: Vec&lt;Frame&gt;,
    idx: usize,
}

impl FrameSource for StaticFrameSource {
    fn next_frame(&amp;mut self) -&gt; Option&lt;Frame&gt; {
        if self.idx &gt;= self.frames.len() {
            return None;
        }
        let f = self.frames[self.idx].clone();
        self.idx += 1;
        Some(f)
    }
}</code></pre>
<h2 id="links-18"><a class="header" href="#links-18">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/interfaces.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-vision_core"><a class="header" href="#design-review-vision_core">Design Review (vision_core)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-1"><a class="header" href="#whats-solid-1">What’s solid</a></h2>
<ul>
<li>Clear interfaces for <code>FrameSource</code>, <code>Detector</code>, <code>Recorder</code>, with lightweight data structs.</li>
<li>Trait-object-friendly design keeps embedding easy (Bevy plugins, CLI tools).</li>
<li><code>BurnDetectorFactory</code> provides an optional hook without forcing Burn dependency on consumers.</li>
</ul>
<h2 id="risks--gaps-1"><a class="header" href="#risks--gaps-1">Risks / gaps</a></h2>
<ul>
<li>Interfaces lack <code>Send + Sync</code>; downstream crates must remember to add bounds when crossing threads.</li>
<li><code>DetectionResult</code>/<code>Frame</code> have fully owned vectors; no buffer reuse guidance—may encourage alloc churn in high-throughput scenarios.</li>
<li>Error signaling is implicit (detectors cannot return failures), so runtime must invent its own fallback channels.</li>
</ul>
<h2 id="refactor-ideas-1"><a class="header" href="#refactor-ideas-1">Refactor ideas</a></h2>
<ul>
<li>Consider adding optional <code>Send + Sync</code> marker traits or aliases for threaded contexts to reduce mistakes.</li>
<li>Provide a “borrowed”/pooled variant or guidance for reusing buffers in hot paths.</li>
<li>Offer an optional error-aware detector trait (or return <code>Result</code>) for cases where distinguishing failure vs. negative detection matters.</li>
</ul>
<h2 id="links-19"><a class="header" href="#links-19">Links</a></h2>
<ul>
<li>Source: <code>vision_core/src/interfaces.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_runtime-overview"><a class="header" href="#vision_runtime-overview">vision_runtime: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-2"><a class="header" href="#problem-statement-2">Problem statement</a></h2>
<p>Provide Bevy plugins for capture and inference built on <code>vision_core</code>, wiring detectors into the runtime loop for live capture/inference scenarios.</p>
<h2 id="scope-2"><a class="header" href="#scope-2">Scope</a></h2>
<ul>
<li>Capture pipeline: render target/readback setup, frame capture to <code>FrameRecord</code>, mode gating.</li>
<li>Inference pipeline: detector handle management (Burn or heuristic), scheduling on captured frames, overlay state updates.</li>
<li>Bevy integration: resources/plugins/systems to plug into sim_core-built apps.</li>
</ul>
<h2 id="non-goals-2"><a class="header" href="#non-goals-2">Non-goals</a></h2>
<ul>
<li>No detector implementations (handled by inference/models).</li>
<li>No recorder sinks (handled by capture_utils/apps), though it emits frame records.</li>
<li>No app/world/domain systems; apps supply those.</li>
</ul>
<h2 id="who-should-use-it-2"><a class="header" href="#who-should-use-it-2">Who should use it</a></h2>
<ul>
<li>App authors wiring capture/inference into Bevy apps built on sim_core.</li>
<li>Contributors extending capture/inference plugins or overlay state handling.</li>
</ul>
<h2 id="links-20"><a class="header" href="#links-20">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-vision-runtime</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_runtime-public-api"><a class="header" href="#vision_runtime-public-api">vision_runtime: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>FrontCameraFrame</td><td>struct</td><td>Captured frame resource</td></tr>
<tr><td>FrontCameraState</td><td>struct</td><td>Tracks front camera state</td></tr>
<tr><td>FrontCameraFrameBuffer</td><td>struct</td><td>Buffer for captured frames</td></tr>
<tr><td>BurnDetector</td><td>struct</td><td>Burn-backed detector wrapper</td></tr>
<tr><td>DetectionOverlayState</td><td>struct</td><td>Overlay UI state for detections</td></tr>
<tr><td>DetectorKind</td><td>enum</td><td>Detector type (Burn/Heuristic)</td></tr>
<tr><td>InferenceThresholds</td><td>struct</td><td>Thresholds for inference (obj/iou)</td></tr>
<tr><td>BurnDetectionResult</td><td>struct</td><td>Wrapper for detection results</td></tr>
<tr><td>BurnInferenceState</td><td>struct</td><td>Tracks inference task state</td></tr>
<tr><td>DetectorHandle</td><td>struct</td><td>Resource holding the active detector</td></tr>
<tr><td>CapturePlugin</td><td>struct</td><td>Bevy plugin to set up capture pipeline</td></tr>
<tr><td>InferencePlugin</td><td>struct</td><td>Bevy plugin to set up inference pipeline</td></tr>
<tr><td>setup_front_capture</td><td>fn</td><td>Configure capture target/readback</td></tr>
<tr><td>track_front_camera_state</td><td>fn</td><td>Track camera state resource</td></tr>
<tr><td>capture_front_camera_frame</td><td>fn</td><td>Capture a frame into buffer</td></tr>
<tr><td>on_front_capture_readback</td><td>fn</td><td>Handle GPU readback for capture</td></tr>
<tr><td>schedule_burn_inference</td><td>fn</td><td>Schedule detector task on frames</td></tr>
<tr><td>threshold_hotkeys</td><td>fn</td><td>Handle hotkeys to adjust thresholds</td></tr>
<tr><td>recorder_draw_rect</td><td>fn</td><td>Draw rect overlay into recorder output</td></tr>
<tr><td>poll_inference_task</td><td>fn</td><td>Poll inference task completion</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>prelude</td></tr>
</tbody>
</table>
</div>
<h2 id="links-21"><a class="header" href="#links-21">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-vision-runtime</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-vision_runtime"><a class="header" href="#traits--generics-vision_runtime">Traits &amp; Generics (vision_runtime)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-2"><a class="header" href="#extensibility-traits-2">Extensibility traits</a></h2>
<ul>
<li>None defined here; runtime composes Bevy systems/resources and consumes interfaces from <code>vision_core</code>.</li>
</ul>
<h2 id="glue-types--resources"><a class="header" href="#glue-types--resources">Glue types / resources</a></h2>
<ul>
<li><code>DetectorHandle</code>: boxed <code>vision_core::Detector</code> trait object + <code>DetectorKind</code> enum to track backend.</li>
<li><code>BurnInferenceState</code>: holds async inference task (<code>Task&lt;InferenceJobResult&gt;</code>) and last result.</li>
<li><code>InferenceThresholds</code>: simple thresholds resource; mutable via hotkeys.</li>
<li><code>BurnDetector</code>, <code>DetectionOverlayState</code>, <code>FrontCameraState</code>, <code>FrontCameraFrameBuffer</code>, <code>FrontCaptureTarget</code>, <code>FrontCaptureReadback</code>: resources to coordinate capture/inference.</li>
</ul>
<h2 id="generics-and-bounds-2"><a class="header" href="#generics-and-bounds-2">Generics and bounds</a></h2>
<ul>
<li>Uses trait objects (<code>Box&lt;dyn Detector + Send + Sync&gt;</code>) to allow swapping heuristic/Burn detectors at runtime.</li>
<li>Async job returns tuple with boxed detector to restore ownership; leverages <code>Task&lt;InferenceJobResult&gt;</code> without exposing lifetimes.</li>
<li>No user-facing generics; types are concrete Bevy resources.</li>
</ul>
<h2 id="design-notes-2"><a class="header" href="#design-notes-2">Design notes</a></h2>
<ul>
<li>Trait-object approach matches Bevy resource storage and allows runtime replacement of detectors (hotkeys, load/fallback).</li>
<li>No custom traits; extension is via providing different <code>Detector</code> implementations to <code>DetectorHandle</code>.</li>
<li>Future extensibility: could generalize inference scheduling via a trait, but current code is purposely concrete to keep Bevy wiring simple.</li>
</ul>
<h2 id="links-22"><a class="header" href="#links-22">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_runtime-module-map"><a class="header" href="#vision_runtime-module-map">vision_runtime: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>lib.rs</code>: Capture and inference pipeline types/functions and Bevy plugins.
<ul>
<li>Plugins: <code>CapturePlugin</code>, <code>InferencePlugin</code>.</li>
<li>Resources: FrontCamera*, DetectorHandle, thresholds.</li>
<li>Systems: capture/readback/inference scheduling, overlay state, hotkeys, polling.</li>
</ul>
</li>
<li><code>prelude</code>: Re-export of commonly used types from lib.rs.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>single-module crate.</li>
<li>relies on vision_core types, inference detectors, and sim_core/Bevy app context.</li>
</ul>
<h2 id="links-23"><a class="header" href="#links-23">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vision_runtime-lifecycle"><a class="header" href="#vision_runtime-lifecycle">vision_runtime: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-2"><a class="header" href="#typical-usage-2">Typical usage</a></h2>
<ol>
<li>Prepare detector and thresholds:
<pre><code class="language-rust ignore">let factory = inference::InferenceFactory;
let thresholds = InferenceThresholds { obj_thresh, iou_thresh };
let detector = factory.build(thresholds, weights.as_deref());
let kind = if weights.is_some() { DetectorKind::Burn } else { DetectorKind::Heuristic };
app.insert_resource(DetectorHandle { detector, kind });
app.insert_resource(thresholds);</code></pre>
</li>
<li>Add plugins:
<pre><code class="language-rust ignore">app.add_plugins((CapturePlugin, InferencePlugin));</code></pre>
</li>
<li>Optionally adjust capture target sizing or add observers.</li>
</ol>
<h2 id="execution-flow-2"><a class="header" href="#execution-flow-2">Execution flow</a></h2>
<ul>
<li>Capture pipeline (CapturePlugin):
<ul>
<li><code>setup_front_capture</code> configures render target/readback resources.</li>
<li><code>track_front_camera_state</code> tracks camera info.</li>
<li><code>capture_front_camera_frame</code> writes frames to buffer; <code>on_front_capture_readback</code> handles GPU readback.</li>
</ul>
</li>
<li>Inference pipeline (InferencePlugin):
<ul>
<li>Schedules detector tasks on captured frames (<code>schedule_burn_inference</code>).</li>
<li>Updates overlay state; handles threshold hotkeys (<code>threshold_hotkeys</code>).</li>
<li><code>poll_inference_task</code> monitors async detector completion.</li>
</ul>
</li>
<li>Recorder interaction: <code>recorder_draw_rect</code> can draw detection overlays into recorder output.</li>
</ul>
<h2 id="notes-1"><a class="header" href="#notes-1">Notes</a></h2>
<ul>
<li>Runs as Bevy plugins; depends on sim_core-built app context.</li>
</ul>
<h2 id="links-24"><a class="header" href="#links-24">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-vision_runtime"><a class="header" href="#error-model-vision_runtime">Error Model (vision_runtime)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-2"><a class="header" href="#errors-defined-2">Errors defined</a></h2>
<ul>
<li>None; runtime uses best-effort fallbacks and logs rather than returning <code>Result</code> from systems.</li>
</ul>
<h2 id="patterns-2"><a class="header" href="#patterns-2">Patterns</a></h2>
<ul>
<li>Inference scheduling is fallible only through the detector implementation; failures are expected to be handled inside <code>vision_core::Detector</code> impls (e.g., return heuristic/fallback).</li>
<li>Capture readback and Bevy systems are written to early-return on missing state; no explicit errors surfaced.</li>
<li>Overlay/debounce state uses option types (<code>Option&lt;Task&lt;_&gt;&gt;</code>, <code>Option&lt;BurnDetectionResult&gt;</code>) to represent absence/in-progress work.</li>
</ul>
<h2 id="recoverability-2"><a class="header" href="#recoverability-2">Recoverability</a></h2>
<ul>
<li>Missing detectors or failed loads should be represented by swapping to <code>DetectorKind::Heuristic</code> (as in <code>inference</code>); runtime itself won’t panic.</li>
<li>Readback mismatch silently ignores events not matching the target.</li>
</ul>
<h2 id="ergonomics-2"><a class="header" href="#ergonomics-2">Ergonomics</a></h2>
<ul>
<li>System-level code avoids panics but also avoids surfacing structured errors. Operational issues are signaled via state (<code>fallback</code> message) or logs.</li>
<li>If richer observability is needed (e.g., metrics/alerts), add events/resources to record failure counts instead of panicking.</li>
</ul>
<h2 id="links-25"><a class="header" href="#links-25">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-vision_runtime"><a class="header" href="#ownership--concurrency-vision_runtime">Ownership &amp; Concurrency (vision_runtime)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-2"><a class="header" href="#ownership-model-2">Ownership model</a></h2>
<ul>
<li>Bevy resources own state: <code>DetectorHandle</code> (boxed detector), <code>BurnInferenceState</code> (pending task), <code>FrontCaptureTarget/State/Buffer</code>, <code>DetectionOverlayState</code>, thresholds, etc.</li>
<li>Ownership of the detector moves into an async task and is returned to the resource when the task completes.</li>
</ul>
<h2 id="concurrency-2"><a class="header" href="#concurrency-2">Concurrency</a></h2>
<ul>
<li>Uses Bevy’s async task pool (<code>AsyncComputeTaskPool</code>) to offload inference. Shared detector is stored in <code>DetectorHandle</code> as <code>Box&lt;dyn Detector + Send + Sync&gt;</code>.</li>
<li>Pending inference runs in a <code>Task&lt;InferenceJobResult&gt;</code>; results are polled and swapped back into the resource.</li>
<li>No explicit locking; ownership is transferred (taken from handle, moved into task, restored).</li>
<li>Feature-gated hotkey handling mutates shared resources on the main thread.</li>
</ul>
<h2 id="borrowing-boundaries-2"><a class="header" href="#borrowing-boundaries-2">Borrowing boundaries</a></h2>
<ul>
<li>Systems borrow resources mutably/exclusively via Bevy ECS; no long-lived borrows are kept beyond a tick.</li>
<li>Capture readback buffers are owned resources; data is cloned when needed.</li>
</ul>
<h2 id="async-boundaries-2"><a class="header" href="#async-boundaries-2">Async boundaries</a></h2>
<ul>
<li><code>schedule_burn_inference</code> spawns async tasks; <code>poll_inference_task</code> polls them. Boundary is explicit via <code>Task</code>.</li>
<li>No futures stored elsewhere; debounce timer ensures only one pending task at a time.</li>
</ul>
<h2 id="risks--notes-2"><a class="header" href="#risks--notes-2">Risks / notes</a></h2>
<ul>
<li>If <code>DetectorHandle</code> is absent, systems early-return (safe). Swapping detector for heuristic during tasks avoids concurrent mutable access without locks.</li>
<li>Ensure detectors used here truly satisfy <code>Send + Sync</code> due to cross-thread execution.</li>
</ul>
<h2 id="links-26"><a class="header" href="#links-26">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-vision_runtime"><a class="header" href="#performance-notes-vision_runtime">Performance Notes (vision_runtime)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-2"><a class="header" href="#hot-paths-2">Hot paths</a></h2>
<ul>
<li>Capture pipeline: GPU readback of the front camera each frame; limited by render/copy bandwidth.</li>
<li>Inference scheduling: per-frame async task executing detector forward pass.</li>
<li>Overlay updates: updating <code>DetectionOverlayState</code> and optionally drawing boxes (if recorder uses it).</li>
</ul>
<h2 id="allocation-patterns-2"><a class="header" href="#allocation-patterns-2">Allocation patterns</a></h2>
<ul>
<li>Minimal per-frame allocations: clones of readback bytes and detection results; <code>DetectionOverlayState</code> reuses vectors but not explicitly preallocated.</li>
<li>Detector task captures frame data (RGBA bytes) by move; could be reused via buffers if needed.</li>
</ul>
<h2 id="trait-objects-2"><a class="header" href="#trait-objects-2">Trait objects</a></h2>
<ul>
<li>Detector stored as trait object; swapping detectors incurs dynamic dispatch but negligible compared to inference cost.</li>
</ul>
<h2 id="assumptions-2"><a class="header" href="#assumptions-2">Assumptions</a></h2>
<ul>
<li>Debounce timer (0.18s) throttles inference to reduce load.</li>
<li>Single pending inference at a time; parallelism limited to one async task.</li>
</ul>
<h2 id="improvements-2"><a class="header" href="#improvements-2">Improvements</a></h2>
<ul>
<li>Add buffer reuse/pooling for readback and detection vectors to cut allocations.</li>
<li>Allow multiple in-flight inference tasks or batch processing if throughput is needed.</li>
<li>Consider dropping heuristic detector logs/allocations when model loaded to reduce noise.</li>
</ul>
<h2 id="links-27"><a class="header" href="#links-27">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-vision_runtime"><a class="header" href="#examples-vision_runtime">Examples (vision_runtime)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-minimal-capture-plugin-usage"><a class="header" href="#1-minimal-capture-plugin-usage">1) Minimal capture plugin usage</a></h2>
<pre><code class="language-rust ignore">use bevy::prelude::*;
use sim_core::ModeSet;
use vision_runtime::CapturePlugin;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(CapturePlugin)
        .add_systems(Update, |state: Res&lt;vision_runtime::FrontCameraState&gt;| {
            info!("Front camera active: {}, frames: {}", state.active, state.frame_counter);
        })
        .run();
}</code></pre>
<h2 id="2-hook-up-a-heuristic-detector-and-run-inference"><a class="header" href="#2-hook-up-a-heuristic-detector-and-run-inference">2) Hook up a heuristic detector and run inference</a></h2>
<pre><code class="language-rust ignore">use bevy::prelude::*;
use sim_core::ModeSet;
use vision_runtime::{CapturePlugin, DetectorHandle, DetectorKind, InferencePlugin, InferenceThresholds};
use vision_core::interfaces::{DetectionResult, Detector, Frame};

// Simple detector for demo purposes
struct Heuristic;
impl Detector for Heuristic {
    fn detect(&amp;mut self, frame: &amp;Frame) -&gt; DetectionResult {
        DetectionResult { frame_id: frame.id, positive: true, confidence: 0.9, boxes: vec![], scores: vec![] }
    }
}

fn main() {
    App::new()
        .insert_resource(sim_core::SimRunMode::Inference)
        .insert_resource(DetectorHandle { detector: Box::new(Heuristic), kind: DetectorKind::Heuristic })
        .insert_resource(InferenceThresholds { obj_thresh: 0.5, iou_thresh: 0.5 })
        .add_plugins(DefaultPlugins)
        .add_plugins((CapturePlugin, InferencePlugin))
        .run();
}</code></pre>
<h2 id="3-poll-inference-results-overlay-state"><a class="header" href="#3-poll-inference-results-overlay-state">3) Poll inference results (overlay state)</a></h2>
<pre><code class="language-rust ignore">use bevy::prelude::*;
use sim_core::ModeSet;
use vision_runtime::{CapturePlugin, InferencePlugin, DetectionOverlayState};

fn log_overlay(overlay: Res&lt;DetectionOverlayState&gt;) {
    if let Some(ms) = overlay.inference_ms {
        info!("Last inference took {:.2} ms, boxes={}", ms, overlay.boxes.len());
    }
}

fn main() {
    App::new()
        .insert_resource(sim_core::SimRunMode::Inference)
        .add_plugins(DefaultPlugins)
        .add_plugins((CapturePlugin, InferencePlugin))
        .add_systems(Update, log_overlay.in_set(ModeSet::Inference))
        .run();
}</code></pre>
<h2 id="links-28"><a class="header" href="#links-28">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-vision_runtime"><a class="header" href="#design-review-vision_runtime">Design Review (vision_runtime)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-2"><a class="header" href="#whats-solid-2">What’s solid</a></h2>
<ul>
<li>Clear separation of capture vs. inference systems; resources encapsulate state cleanly.</li>
<li>Async inference via Bevy task pool with explicit debounce avoids hammering the model.</li>
<li>Trait-object detectors make it easy to swap heuristic/Burn without changing systems.</li>
</ul>
<h2 id="risks--gaps-2"><a class="header" href="#risks--gaps-2">Risks / gaps</a></h2>
<ul>
<li>Single pending inference and mutex-guarded detector mean throughput is limited; scaling to higher FPS would need redesign.</li>
<li>Readback/inference allocations aren’t pooled; could churn in long runs.</li>
<li>Error/fallback signaling is implicit (overlay fallback string); lacks structured telemetry or counters.</li>
</ul>
<h2 id="refactor-ideas-2"><a class="header" href="#refactor-ideas-2">Refactor ideas</a></h2>
<ul>
<li>Add buffer pooling for readback bytes and detection vectors.</li>
<li>Support multiple in-flight inference tasks or a small queue; allow batch processing for throughput.</li>
<li>Expose metrics/events for failures, fallback usage, inference latency distributions.</li>
</ul>
<h2 id="links-29"><a class="header" href="#links-29">Links</a></h2>
<ul>
<li>Source: <code>vision_runtime/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data_contracts-overview"><a class="header" href="#data_contracts-overview">data_contracts: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-3"><a class="header" href="#problem-statement-3">Problem statement</a></h2>
<p>Define and validate shared schemas for captures, manifests, and warehouse shards used across the CortenForge stack.</p>
<h2 id="scope-3"><a class="header" href="#scope-3">Scope</a></h2>
<ul>
<li>Run manifest schema (id/seed/camera/resize/letterbox/frame count/checksum).</li>
<li>Frame label schema (bbox norm/px, class, metadata, overlays optional).</li>
<li>Warehouse manifest/shard schemas for ETL/training.</li>
<li>Validation helpers to enforce ranges/required fields.</li>
</ul>
<h2 id="non-goals-3"><a class="header" href="#non-goals-3">Non-goals</a></h2>
<ul>
<li>No I/O or recorder sinks; consumers read/write using these schemas.</li>
<li>No runtime/Bevy integration; pure data definitions.</li>
<li>No app-specific metadata beyond generic fields.</li>
</ul>
<h2 id="who-should-use-it-3"><a class="header" href="#who-should-use-it-3">Who should use it</a></h2>
<ul>
<li>Capture/recorder code (capture_utils/tools) writing manifests/labels.</li>
<li>ETL/training pipelines consuming warehouse manifests/shards.</li>
<li>Contributors updating schemas with strict validation.</li>
</ul>
<h2 id="links-30"><a class="header" href="#links-30">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/lib.rs</code></li>
<li>Module: <code>data_contracts/src/capture.rs</code></li>
<li>Module: <code>data_contracts/src/manifest.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-data-contracts</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data_contracts-public-api"><a class="header" href="#data_contracts-public-api">data_contracts: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>PolypLabel</td><td>struct</td><td>Label for a captured frame (center_world + bbox)</td></tr>
<tr><td>CaptureMetadata</td><td>struct</td><td>Capture-level metadata</td></tr>
<tr><td>ValidationError</td><td>enum</td><td>Errors from schema validation</td></tr>
<tr><td>RunManifestSchemaVersion</td><td>enum</td><td>Manifest schema version identifier</td></tr>
<tr><td>RunManifest</td><td>struct</td><td>Run manifest (id/seed/camera/resize/frame count/checksum)</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>capture, manifest</td></tr>
<tr><td>Re-exports</td><td>re-export</td><td>CaptureMetadata, PolypLabel, ValidationError, RunManifest, RunManifestSchemaVersion</td></tr>
</tbody>
</table>
</div>
<h2 id="links-31"><a class="header" href="#links-31">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/lib.rs</code></li>
<li>Module: <code>data_contracts/src/capture.rs</code></li>
<li>Module: <code>data_contracts/src/manifest.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-data-contracts</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-data_contracts"><a class="header" href="#traits--generics-data_contracts">Traits &amp; Generics (data_contracts)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-3"><a class="header" href="#extensibility-traits-3">Extensibility traits</a></h2>
<ul>
<li>None; crate is pure data models plus validation helpers.</li>
</ul>
<h2 id="glue-types-2"><a class="header" href="#glue-types-2">Glue types</a></h2>
<ul>
<li>Plain structs/enums for schemas: <code>PolypLabel</code>, <code>CaptureMetadata</code>, <code>RunManifest</code>, <code>RunManifestSchemaVersion</code>.</li>
<li>Validation helpers on structs (<code>validate</code>) return <code>Result&lt;(), ValidationError&gt;</code> or <code>Result&lt;(), String&gt;</code>.</li>
</ul>
<h2 id="generics-and-bounds-3"><a class="header" href="#generics-and-bounds-3">Generics and bounds</a></h2>
<ul>
<li>No generics; all types are concrete, serde-serializable structures. Validation errors use <code>thiserror</code> enum (<code>ValidationError</code>) or <code>String</code>.</li>
<li>Uses <code>PathBuf</code> for paths; no lifetime generics involved.</li>
</ul>
<h2 id="design-notes-3"><a class="header" href="#design-notes-3">Design notes</a></h2>
<ul>
<li>Keeps contracts simple and portable (serde everywhere). If additional schema versions appear, extend <code>RunManifestSchemaVersion</code> and gate validation per version.</li>
<li>Validation is minimal; downstream loaders should still handle IO/shape errors.</li>
</ul>
<h2 id="links-32"><a class="header" href="#links-32">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/capture.rs</code></li>
<li>Source: <code>data_contracts/src/manifest.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data_contracts-module-map"><a class="header" href="#data_contracts-module-map">data_contracts: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>capture</code>: Capture metadata/labels schema; validation errors. Types: PolypLabel, CaptureMetadata, ValidationError.</li>
<li><code>manifest</code>: Run manifest schema/versioning. Types: RunManifest, RunManifestSchemaVersion.</li>
<li><code>lib.rs</code>: Re-exports capture/manifest modules and types.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>none beyond serde.</li>
<li>consumers are capture/utils/tools/training.</li>
</ul>
<h2 id="links-33"><a class="header" href="#links-33">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data_contracts-lifecycle"><a class="header" href="#data_contracts-lifecycle">data_contracts: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-3"><a class="header" href="#typical-usage-3">Typical usage</a></h2>
<ul>
<li>Define/load manifests and labels:
<pre><code class="language-rust ignore">let manifest: RunManifest = serde_json::from_str(json_str)?;
manifest.validate()?;
let label = PolypLabel { /* fields */ };</code></pre>
</li>
<li>Validate captures/warehouse artifacts against schemas before ETL/training.</li>
</ul>
<h2 id="execution-flow-3"><a class="header" href="#execution-flow-3">Execution flow</a></h2>
<ul>
<li>Producers (recorder/tools) construct <code>RunManifest</code> and <code>PolypLabel</code> per capture.</li>
<li>Consumers (ETL/training/tools) deserialize manifests/labels and optionally call validation helpers.</li>
<li>Schema versioning via <code>RunManifestSchemaVersion</code> allows compatibility checks.</li>
</ul>
<h2 id="notes-2"><a class="header" href="#notes-2">Notes</a></h2>
<ul>
<li>Pure data types/validation; no runtime lifecycle. Initialization/teardown managed by callers.</li>
</ul>
<h2 id="links-34"><a class="header" href="#links-34">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/manifest.rs</code></li>
<li>Source: <code>data_contracts/src/capture.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-data_contracts"><a class="header" href="#error-model-data_contracts">Error Model (data_contracts)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-3"><a class="header" href="#errors-defined-3">Errors defined</a></h2>
<ul>
<li><code>ValidationError</code> (enum): invalid bbox order/range (<code>InvalidBboxPx</code>, <code>InvalidBboxNorm</code>), <code>MissingImage</code>.</li>
<li><code>RunManifest::validate</code> returns <code>Result&lt;(), String&gt;</code> for timestamp/max_frames sanity.</li>
</ul>
<h2 id="patterns-3"><a class="header" href="#patterns-3">Patterns</a></h2>
<ul>
<li>Validation errors are sync and deterministic; no IO inside validation.</li>
<li>Serde (de)serializes structs; serde errors are not wrapped here (handled by callers).</li>
</ul>
<h2 id="recoverability-3"><a class="header" href="#recoverability-3">Recoverability</a></h2>
<ul>
<li>Validation errors are recoverable: callers can log/skip/repair input. No panics or fatal errors.</li>
</ul>
<h2 id="ergonomics-3"><a class="header" href="#ergonomics-3">Ergonomics</a></h2>
<ul>
<li><code>ValidationError</code> uses <code>thiserror</code> for display strings; suitable for user-facing logs.</li>
<li>Manifest validation returning <code>String</code> is less typed; consider moving to a typed error if extended.</li>
</ul>
<h2 id="links-35"><a class="header" href="#links-35">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/capture.rs</code></li>
<li>Source: <code>data_contracts/src/manifest.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-data_contracts"><a class="header" href="#ownership--concurrency-data_contracts">Ownership &amp; Concurrency (data_contracts)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-3"><a class="header" href="#ownership-model-3">Ownership model</a></h2>
<ul>
<li>Pure data structs (<code>RunManifest</code>, <code>CaptureMetadata</code>, etc.) with owned fields (<code>PathBuf</code>, <code>Vec</code>); no shared ownership.</li>
<li>Validation methods borrow <code>&amp;self</code> briefly; no stored borrows.</li>
</ul>
<h2 id="concurrency-3"><a class="header" href="#concurrency-3">Concurrency</a></h2>
<ul>
<li>No threading/async concerns; types are <code>Send</code>/<code>Sync</code> by virtue of fields, but the crate does not enforce cross-thread use.</li>
</ul>
<h2 id="borrowing-boundaries-3"><a class="header" href="#borrowing-boundaries-3">Borrowing boundaries</a></h2>
<ul>
<li>All data is owned; callers choose whether to share/clone. Validation does not mutate.</li>
</ul>
<h2 id="async-boundaries-3"><a class="header" href="#async-boundaries-3">Async boundaries</a></h2>
<ul>
<li>None; crate is synchronous and side-effect free (aside from validation checks).</li>
</ul>
<h2 id="risks--notes-3"><a class="header" href="#risks--notes-3">Risks / notes</a></h2>
<ul>
<li>Safe to share across threads if caller needs (serde types are Send/Sync); concurrency behavior is entirely caller-controlled.</li>
</ul>
<h2 id="links-36"><a class="header" href="#links-36">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/capture.rs</code></li>
<li>Source: <code>data_contracts/src/manifest.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-data_contracts"><a class="header" href="#performance-notes-data_contracts">Performance Notes (data_contracts)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-3"><a class="header" href="#hot-paths-3">Hot paths</a></h2>
<ul>
<li>None; crate is schema-only. Serialization/deserialization is the only work.</li>
</ul>
<h2 id="allocation-patterns-3"><a class="header" href="#allocation-patterns-3">Allocation patterns</a></h2>
<ul>
<li>Owned vectors/paths in structs; serde allocates as needed. No pooling or reuse.</li>
</ul>
<h2 id="trait-objects-3"><a class="header" href="#trait-objects-3">Trait objects</a></h2>
<ul>
<li>None.</li>
</ul>
<h2 id="assumptions-3"><a class="header" href="#assumptions-3">Assumptions</a></h2>
<ul>
<li>Overhead is negligible relative to IO; performance driven by serde usage in callers.</li>
</ul>
<h2 id="improvements-3"><a class="header" href="#improvements-3">Improvements</a></h2>
<ul>
<li>None required; if serde overhead becomes an issue, consider borrowing-friendly variants, but current usage is fine for run-level metadata.</li>
</ul>
<h2 id="links-37"><a class="header" href="#links-37">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-data_contracts"><a class="header" href="#examples-data_contracts">Examples (data_contracts)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-validate-a-label-entry"><a class="header" href="#1-validate-a-label-entry">1) Validate a label entry</a></h2>
<pre><code class="language-rust ignore">use data_contracts::capture::PolypLabel;

fn main() {
    let lbl = PolypLabel { center_world: [0.0, 0.0, 0.0], bbox_px: Some([10.0, 20.0, 50.0, 60.0]), bbox_norm: None };
    lbl.validate().expect("valid bbox");
}</code></pre>
<h2 id="2-build-and-validate-capture-metadata"><a class="header" href="#2-build-and-validate-capture-metadata">2) Build and validate capture metadata</a></h2>
<pre><code class="language-rust ignore">use data_contracts::capture::{CaptureMetadata, PolypLabel};

fn main() {
    let meta = CaptureMetadata {
        frame_id: 1,
        sim_time: 0.1,
        unix_time: 1_700_000_000.0,
        image: "images/frame_00001.png".into(),
        image_present: true,
        camera_active: true,
        polyp_seed: 42,
        polyp_labels: vec![PolypLabel { center_world: [0.0, 0.0, 0.0], bbox_px: None, bbox_norm: Some([0.1, 0.1, 0.2, 0.2]) }],
    };
    meta.validate().expect("metadata valid");
}</code></pre>
<h2 id="3-create-and-check-a-run-manifest"><a class="header" href="#3-create-and-check-a-run-manifest">3) Create and check a run manifest</a></h2>
<pre><code class="language-rust ignore">use data_contracts::manifest::{RunManifest, RunManifestSchemaVersion};
use std::path::PathBuf;

fn main() {
    let manifest = RunManifest {
        schema_version: RunManifestSchemaVersion::V1,
        seed: Some(1234),
        output_root: PathBuf::from("assets/datasets/captures"),
        run_dir: PathBuf::from("assets/datasets/captures/run_00001"),
        started_at_unix: 1_700_000_000.0,
        max_frames: Some(10),
    };
    manifest.validate().expect("manifest valid");
}</code></pre>
<h2 id="links-38"><a class="header" href="#links-38">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/capture.rs</code></li>
<li>Source: <code>data_contracts/src/manifest.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-data_contracts"><a class="header" href="#design-review-data_contracts">Design Review (data_contracts)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-3"><a class="header" href="#whats-solid-3">What’s solid</a></h2>
<ul>
<li>Small, serde-friendly schemas with explicit validation helpers.</li>
<li>Clear separation between capture metadata and run manifest; easy to version.</li>
</ul>
<h2 id="risks--gaps-3"><a class="header" href="#risks--gaps-3">Risks / gaps</a></h2>
<ul>
<li><code>RunManifest::validate</code> returns <code>String</code> errors; less structured than <code>ValidationError</code>.</li>
<li>Schema evolution not yet exercised; adding versions may introduce branching logic and potential duplication.</li>
<li>No borrowed/zero-copy variants; large data would require cloning.</li>
</ul>
<h2 id="refactor-ideas-3"><a class="header" href="#refactor-ideas-3">Refactor ideas</a></h2>
<ul>
<li>Introduce a typed manifest error enum for consistency with capture validation.</li>
<li>Plan versioning strategy (e.g., enum variants per version + conversion helpers) before adding new schema versions.</li>
<li>If performance becomes an issue, consider borrowed deserialization (serde <code>Cow</code>) to avoid cloning strings/paths.</li>
</ul>
<h2 id="links-39"><a class="header" href="#links-39">Links</a></h2>
<ul>
<li>Source: <code>data_contracts/src/capture.rs</code></li>
<li>Source: <code>data_contracts/src/manifest.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="capture_utils-overview"><a class="header" href="#capture_utils-overview">capture_utils: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-4"><a class="header" href="#problem-statement-4">Problem statement</a></h2>
<p>Provide recorder sinks and capture helpers (overlay/prune) compatible with CortenForge schemas for use in runtime and tooling.</p>
<h2 id="scope-4"><a class="header" href="#scope-4">Scope</a></h2>
<ul>
<li>Default JSON recorder sink for frame labels.</li>
<li>Overlay/prune helpers used by tools/tests.</li>
<li>Helpers aligned with <code>data_contracts</code> schemas.</li>
</ul>
<h2 id="non-goals-4"><a class="header" href="#non-goals-4">Non-goals</a></h2>
<ul>
<li>No recorder meta/world state definitions (from sim_core/app).</li>
<li>No runtime plugins (vision_runtime) or detector logic.</li>
<li>No app-specific sinks; keep schema-compatible for ETL/training.</li>
</ul>
<h2 id="who-should-use-it-4"><a class="header" href="#who-should-use-it-4">Who should use it</a></h2>
<ul>
<li>Runtime recorder pipelines (sim_core/apps) needing a default sink.</li>
<li>Tools performing overlay/prune on captures.</li>
<li>Contributors adding sinks while preserving schema compatibility.</li>
</ul>
<h2 id="links-40"><a class="header" href="#links-40">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-capture-utils</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="capture_utils-public-api"><a class="header" href="#capture_utils-public-api">capture_utils: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>JsonRecorder</td><td>struct</td><td>Default JSON recorder sink for frame labels</td></tr>
<tr><td>generate_overlays</td><td>fn</td><td>Render overlays for a capture run</td></tr>
<tr><td>prune_run</td><td>fn</td><td>Copy a run into a filtered root and return kept/skipped counts</td></tr>
</tbody>
</table>
</div>
<h2 id="links-41"><a class="header" href="#links-41">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-capture-utils</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-capture_utils"><a class="header" href="#traits--generics-capture_utils">Traits &amp; Generics (capture_utils)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-4"><a class="header" href="#extensibility-traits-4">Extensibility traits</a></h2>
<ul>
<li>None exported; primary interfaces come from <code>vision_core::Recorder</code> which this crate implements.</li>
</ul>
<h2 id="glue-traits"><a class="header" href="#glue-traits">Glue traits</a></h2>
<ul>
<li>Internal helper trait <code>GetPixelChecked</code> (sealed to this module) to avoid panics when drawing rectangles. Provides <code>get_pixel_mut_checked(&amp;mut self, x, y) -&gt; Option&lt;&amp;mut Rgba&lt;u8&gt;&gt;</code>.</li>
</ul>
<h2 id="generics-and-bounds-4"><a class="header" href="#generics-and-bounds-4">Generics and bounds</a></h2>
<ul>
<li><code>JsonRecorder</code> implements <code>vision_core::Recorder</code> as a trait object friendly sink; no generics.</li>
<li>No generic data structures; functions operate on concrete types (<code>Path</code>, <code>RgbaImage</code>, etc.).</li>
</ul>
<h2 id="design-notes-4"><a class="header" href="#design-notes-4">Design notes</a></h2>
<ul>
<li>Intentional lack of generics keeps recorder/overlay utilities straightforward and trait-object compatible.</li>
<li>If additional recorder types are added, implement <code>vision_core::Recorder</code> rather than introducing new traits to keep consumers unified.</li>
</ul>
<h2 id="links-42"><a class="header" href="#links-42">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="capture_utils-module-map"><a class="header" href="#capture_utils-module-map">capture_utils: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>lib.rs</code>: Single-module crate containing:
<ul>
<li><code>JsonRecorder</code>: Default JSON recorder sink implementing <code>vision_core::Recorder</code> for labels.</li>
<li><code>generate_overlays</code>: Helper to render overlays from label JSONs in a run dir.</li>
<li><code>prune_run</code>: Helper to copy a run into a filtered root and report kept/skipped counts.</li>
<li>Local helper <code>draw_rect</code> for overlay rendering.</li>
</ul>
</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>Uses <code>data_contracts</code> for schemas and <code>vision_core</code> interfaces for recorder integration.</li>
<li>Uses standard image/fs utilities.</li>
<li>Consumed by runtime/apps/tools.</li>
</ul>
<h2 id="links-43"><a class="header" href="#links-43">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="capture_utils-lifecycle"><a class="header" href="#capture_utils-lifecycle">capture_utils: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-4"><a class="header" href="#typical-usage-4">Typical usage</a></h2>
<ul>
<li>Use default recorder sink:
<pre><code class="language-rust ignore">use vision_core::prelude::{Frame, FrameRecord};
let mut recorder = JsonRecorder::new(run_dir);
let frame = Frame {
    id: 1,
    timestamp: 0.0,
    rgba: None,
    size: (640, 480),
    path: Some("images/frame_00001.png".into()),
};
let record = FrameRecord {
    frame,
    labels: &amp;[],
    camera_active: true,
    polyp_seed: 1,
};
recorder.record(&amp;record)?;</code></pre>
</li>
<li>Overlay/prune helpers in tools:
<pre><code class="language-rust ignore">generate_overlays(run_dir)?;
let (_kept, _dropped) = prune_run(input_run, output_root)?;</code></pre>
</li>
</ul>
<h2 id="execution-flow-4"><a class="header" href="#execution-flow-4">Execution flow</a></h2>
<ul>
<li>Recorder sinks consume labels/frames produced by runtime/tools and write JSON manifests.</li>
<li>Overlay/prune functions operate on capture directories (frames/labels) to produce overlays or filtered runs.</li>
</ul>
<h2 id="notes-3"><a class="header" href="#notes-3">Notes</a></h2>
<ul>
<li>Stateless helpers; lifecycle driven by callers (runtime/tools).</li>
</ul>
<h2 id="links-44"><a class="header" href="#links-44">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-capture_utils"><a class="header" href="#error-model-capture_utils">Error Model (capture_utils)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-4"><a class="header" href="#errors-defined-4">Errors defined</a></h2>
<ul>
<li>Uses existing error types:
<ul>
<li>Implements <code>vision_core::Recorder::record</code> returning <code>std::io::Result&lt;()&gt;</code>.</li>
<li><code>generate_overlays</code> returns <code>anyhow::Result&lt;()&gt;</code>.</li>
<li><code>prune_run</code> returns <code>std::io::Result&lt;(usize, usize)&gt;</code>.</li>
</ul>
</li>
<li>Internal validation relies on <code>data_contracts::ValidationError</code> (converted to <code>io::Error</code> in recorder).</li>
</ul>
<h2 id="patterns-4"><a class="header" href="#patterns-4">Patterns</a></h2>
<ul>
<li>Recorder maps validation failure to <code>io::Error::other("validation failed: …")</code>.</li>
<li>Overlay generation skips invalid/missing entries silently (continues on errors).</li>
<li>Pruning propagates IO errors; copies files best-effort.</li>
</ul>
<h2 id="recoverability-4"><a class="header" href="#recoverability-4">Recoverability</a></h2>
<ul>
<li>Recorder errors are caller-visible; should be handled/retried by runtime.</li>
<li>Overlay generation best-effort; failures on individual files don’t abort the run (may miss overlays).</li>
<li>Prune errors bubble up; callers can report and stop.</li>
</ul>
<h2 id="ergonomics-4"><a class="header" href="#ergonomics-4">Ergonomics</a></h2>
<ul>
<li>Mixed <code>anyhow</code> and <code>io::Error</code>; fine for tooling but consider consistent typed errors if this crate is reused in libraries.</li>
<li>Silent skips in <code>generate_overlays</code> are convenient but may hide data issues; add logging if stricter guarantees are needed.</li>
</ul>
<h2 id="links-45"><a class="header" href="#links-45">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-capture_utils"><a class="header" href="#ownership--concurrency-capture_utils">Ownership &amp; Concurrency (capture_utils)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-4"><a class="header" href="#ownership-model-4">Ownership model</a></h2>
<ul>
<li><code>JsonRecorder</code> owns its <code>run_dir</code>; records are written synchronously.</li>
<li>Overlay/prune operations own their buffers and operate eagerly on disk.</li>
<li>No shared state across calls; helper trait <code>GetPixelChecked</code> is implemented on <code>RgbaImage</code>.</li>
</ul>
<h2 id="concurrency-4"><a class="header" href="#concurrency-4">Concurrency</a></h2>
<ul>
<li>All functions are synchronous; no <code>Send/Sync</code> requirements beyond what the caller imposes.</li>
<li>Recorder is typically used as a boxed trait object in other crates; must be <code>Send + Sync</code> to fit those contexts, but this crate does not add interior mutability.</li>
</ul>
<h2 id="borrowing-boundaries-4"><a class="header" href="#borrowing-boundaries-4">Borrowing boundaries</a></h2>
<ul>
<li><code>Recorder::record</code> borrows <code>&amp;FrameRecord</code> for the duration of serialization; no retained borrows.</li>
<li>Overlay/prune read/write files and clone data as needed; no long-lived references.</li>
</ul>
<h2 id="async-boundaries-4"><a class="header" href="#async-boundaries-4">Async boundaries</a></h2>
<ul>
<li>None; intended for blocking, file-based workflows. If used in async contexts, wrap in spawn/blocking tasks.</li>
</ul>
<h2 id="risks--notes-4"><a class="header" href="#risks--notes-4">Risks / notes</a></h2>
<ul>
<li>Concurrent writes to the same run directory from multiple recorders could collide; caller must coordinate if using in multithreaded scenarios.</li>
</ul>
<h2 id="links-46"><a class="header" href="#links-46">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-capture_utils"><a class="header" href="#performance-notes-capture_utils">Performance Notes (capture_utils)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-4"><a class="header" href="#hot-paths-4">Hot paths</a></h2>
<ul>
<li>Recording captures: JSON serialization per frame; disk IO dominates.</li>
<li>Overlay generation: per-image decode + draw loops over bounding boxes.</li>
<li>Pruning: file copy operations across run directories.</li>
</ul>
<h2 id="allocation-patterns-4"><a class="header" href="#allocation-patterns-4">Allocation patterns</a></h2>
<ul>
<li><code>JsonRecorder</code> allocates per-frame JSON buffer; uses <code>BufWriter</code> to reduce syscalls.</li>
<li>Overlay generation allocates decoded image buffers; no reuse/pooling.</li>
<li>Prune copies files; no large in-memory buffers beyond image decode.</li>
</ul>
<h2 id="trait-objects-4"><a class="header" href="#trait-objects-4">Trait objects</a></h2>
<ul>
<li>Recorder invoked via trait object; negligible overhead compared to IO.</li>
</ul>
<h2 id="assumptions-4"><a class="header" href="#assumptions-4">Assumptions</a></h2>
<ul>
<li>Throughput bounded by filesystem. Image decode/encode via <code>image</code> crate is the main CPU cost in overlays.</li>
</ul>
<h2 id="improvements-4"><a class="header" href="#improvements-4">Improvements</a></h2>
<ul>
<li>Add buffer reuse/pooling for overlay images if processing large datasets.</li>
<li>Parallelize overlay generation/pruning per file for speedups (currently sequential).</li>
</ul>
<h2 id="links-47"><a class="header" href="#links-47">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-capture_utils"><a class="header" href="#examples-capture_utils">Examples (capture_utils)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-write-labels-with-jsonrecorder"><a class="header" href="#1-write-labels-with-jsonrecorder">1) Write labels with JsonRecorder</a></h2>
<pre><code class="language-rust ignore">use capture_utils::JsonRecorder;
use vision_core::prelude::{Frame, FrameRecord};

fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut recorder = JsonRecorder::new("assets/datasets/captures/run_00001");
    let frame = Frame {
        id: 1,
        timestamp: 0.1,
        rgba: None,
        size: (640, 480),
        path: Some("images/frame_00001.png".into()),
    };
    let record = FrameRecord {
        frame,
        labels: &amp;[],
        camera_active: true,
        polyp_seed: 42,
    };
    recorder.record(&amp;record)
}</code></pre>
<h2 id="2-generate-overlays-for-a-run"><a class="header" href="#2-generate-overlays-for-a-run">2) Generate overlays for a run</a></h2>
<pre><code class="language-rust ignore">use std::path::Path;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    capture_utils::generate_overlays(Path::new("assets/datasets/captures/run_00001"))
}</code></pre>
<h2 id="3-copy-a-run-into-a-filtered-root-and-report-counts"><a class="header" href="#3-copy-a-run-into-a-filtered-root-and-report-counts">3) Copy a run into a filtered root and report counts</a></h2>
<pre><code class="language-rust ignore">use std::path::Path;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let (kept, skipped) = capture_utils::prune_run(
        Path::new("assets/datasets/captures/run_00001"),
        Path::new("assets/datasets/captures_filtered"),
    )?;
    println!("kept {kept} labels, skipped {skipped}");
    Ok(())
}</code></pre>
<h2 id="links-48"><a class="header" href="#links-48">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-capture_utils"><a class="header" href="#design-review-capture_utils">Design Review (capture_utils)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-4"><a class="header" href="#whats-solid-4">What’s solid</a></h2>
<ul>
<li>Simple, focused helpers for recording, overlay generation, and pruning.</li>
<li>Recorder validates against shared contracts; avoids writing bad labels.</li>
<li>Uses standard <code>image</code> crate and serde; easy to reason about.</li>
</ul>
<h2 id="risks--gaps-4"><a class="header" href="#risks--gaps-4">Risks / gaps</a></h2>
<ul>
<li>Overlay generation and pruning are sequential and silent on per-file failures; large datasets may hide errors.</li>
<li>Recorder supports only JSON output; no configurable formats or compression.</li>
<li>No pooling/parallelism; could be slow at scale.</li>
</ul>
<h2 id="refactor-ideas-4"><a class="header" href="#refactor-ideas-4">Refactor ideas</a></h2>
<ul>
<li>Add logging/metrics for skipped overlays and errors to improve visibility.</li>
<li>Introduce optional parallel overlay/prune processing and buffer reuse for speed.</li>
<li>Consider pluggable recorder formats (e.g., msgpack) to reduce size or improve speed while keeping contract compatibility.</li>
</ul>
<h2 id="links-49"><a class="header" href="#links-49">Links</a></h2>
<ul>
<li>Source: <code>capture_utils/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="models-overview"><a class="header" href="#models-overview">models: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-5"><a class="header" href="#problem-statement-5">Problem statement</a></h2>
<p>Define Burn-based model architectures/configs (TinyDet/BigDet) used across training and inference in the CortenForge stack.</p>
<h2 id="scope-5"><a class="header" href="#scope-5">Scope</a></h2>
<ul>
<li>Model definitions/configs for TinyDet and BigDet.</li>
<li>Feature flags to gate variants (<code>tinydet</code>, <code>bigdet</code>).</li>
<li>Pure model code; no training loop or inference factory logic.</li>
</ul>
<h2 id="non-goals-5"><a class="header" href="#non-goals-5">Non-goals</a></h2>
<ul>
<li>No dataset loading or training/eval loop (handled by training).</li>
<li>No checkpoint loading or detector factory (handled by inference).</li>
<li>No app/domain-specific heads beyond provided variants.</li>
</ul>
<h2 id="who-should-use-it-5"><a class="header" href="#who-should-use-it-5">Who should use it</a></h2>
<ul>
<li>Training crate to construct models/checkpoints.</li>
<li>Inference crate to load checkpoints and build detectors.</li>
<li>Contributors adding model variants or adjusting configs.</li>
</ul>
<h2 id="links-50"><a class="header" href="#links-50">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/models</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="models-public-api"><a class="header" href="#models-public-api">models: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>TinyDetConfig</td><td>struct</td><td>Configuration for TinyDet model</td></tr>
<tr><td><code>TinyDet&lt;B&gt;</code></td><td>struct</td><td>TinyDet model generic over Burn backend</td></tr>
<tr><td>BigDetConfig</td><td>struct</td><td>Configuration for BigDet model</td></tr>
<tr><td><code>BigDet&lt;B&gt;</code></td><td>struct</td><td>BigDet model generic over Burn backend</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>prelude</td></tr>
</tbody>
</table>
</div>
<h2 id="links-51"><a class="header" href="#links-51">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/models</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-models"><a class="header" href="#traits--generics-models">Traits &amp; Generics (models)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-5"><a class="header" href="#extensibility-traits-5">Extensibility traits</a></h2>
<ul>
<li>None defined; extensibility via generic backends and configuration structs.</li>
</ul>
<h2 id="generics-and-bounds-5"><a class="header" href="#generics-and-bounds-5">Generics and bounds</a></h2>
<ul>
<li><code>TinyDet&lt;B: Backend&gt;</code> and <code>BigDet&lt;B: Backend&gt;</code> are generic over Burn backends.</li>
<li>Config structs (<code>TinyDetConfig</code>, <code>BigDetConfig</code>) are concrete; no trait bounds.</li>
<li>Methods take <code>&amp;B::Device</code> to construct layers; forward methods operate on <code>Tensor&lt;B, 2&gt;</code> (and <code>Tensor&lt;B, 3&gt;</code> outputs for multibox).</li>
<li>Uses derive <code>Module</code> for Burn module composition; no custom traits introduced.</li>
</ul>
<h2 id="design-notes-5"><a class="header" href="#design-notes-5">Design notes</a></h2>
<ul>
<li>Generic over backend keeps CPU/GPU swap flexible without additional traits.</li>
<li>No trait objects; consumers choose backend type at compile time.</li>
<li><code>forward_multibox</code> enforces box ordering/clamping procedurally—no trait/generic constraints there.</li>
</ul>
<h2 id="links-52"><a class="header" href="#links-52">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="models-module-map"><a class="header" href="#models-module-map">models: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>lib.rs</code>: Defines TinyDet/BigDet configs and models; includes a <code>prelude</code> for re-exports.</li>
<li><code>prelude</code>: Convenience re-export of core model types.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>self-contained definitions.</li>
<li>consumed by training and inference.</li>
</ul>
<h2 id="links-53"><a class="header" href="#links-53">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="models-lifecycle"><a class="header" href="#models-lifecycle">models: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-5"><a class="header" href="#typical-usage-5">Typical usage</a></h2>
<ul>
<li>Construct model from config and backend:
<pre><code class="language-rust ignore">type B = burn::backend::ndarray::NdArrayBackend&lt;f32&gt;;
let device = B::Device::default();
let model = TinyDet::&lt;B&gt;::new(TinyDetConfig::default(), &amp;device);</code></pre>
</li>
<li>Swap to BigDet or a different backend type if your dependency graph enables it.</li>
</ul>
<h2 id="execution-flow-5"><a class="header" href="#execution-flow-5">Execution flow</a></h2>
<ul>
<li>Consumer (training/inference) selects config (TinyDet/BigDet) and backend type.</li>
<li>Build model instance; training/inference crates handle forward/backward/checkpointing.</li>
</ul>
<h2 id="notes-4"><a class="header" href="#notes-4">Notes</a></h2>
<ul>
<li>Stateless definitions; lifecycle controlled by training/inference code.</li>
</ul>
<h2 id="links-54"><a class="header" href="#links-54">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-models"><a class="header" href="#error-model-models">Error Model (models)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-5"><a class="header" href="#errors-defined-5">Errors defined</a></h2>
<ul>
<li>None; model constructors/forwards are infallible and rely on Burn for panic/assert behavior.</li>
</ul>
<h2 id="patterns-5"><a class="header" href="#patterns-5">Patterns</a></h2>
<ul>
<li>Construction uses Burn <code>init</code> APIs; panics would only arise from backend/device issues.</li>
<li>Forward/multibox do not return <code>Result</code>; numeric issues (NaN, etc.) propagate through tensors.</li>
</ul>
<h2 id="recoverability-5"><a class="header" href="#recoverability-5">Recoverability</a></h2>
<ul>
<li>No explicit error channels; callers must detect/handle invalid outputs (e.g., NaNs) at higher layers.</li>
</ul>
<h2 id="ergonomics-5"><a class="header" href="#ergonomics-5">Ergonomics</a></h2>
<ul>
<li>Simplicity suits small demo models. If expanding to larger models or dynamic loading, consider returning <code>Result</code> from builders when IO/shape validation is involved.</li>
</ul>
<h2 id="links-55"><a class="header" href="#links-55">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-models"><a class="header" href="#ownership--concurrency-models">Ownership &amp; Concurrency (models)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-5"><a class="header" href="#ownership-model-5">Ownership model</a></h2>
<ul>
<li>Models own their layers and configuration; no shared/global state.</li>
<li>Inputs/outputs are Burn tensors; ownership follows Burn semantics (reference-counted buffers under the hood).</li>
</ul>
<h2 id="concurrency-5"><a class="header" href="#concurrency-5">Concurrency</a></h2>
<ul>
<li>No threading/async in this crate. Concurrency depends on backend (e.g., WGPU handles GPU async internally).</li>
<li>Models are immutable once constructed; <code>forward</code> takes <code>&amp;self</code>, enabling shared references across threads if the backend supports it.</li>
</ul>
<h2 id="borrowing-boundaries-5"><a class="header" href="#borrowing-boundaries-5">Borrowing boundaries</a></h2>
<ul>
<li>No retained borrows; forward methods consume input tensors by value (owned).</li>
</ul>
<h2 id="async-boundaries-5"><a class="header" href="#async-boundaries-5">Async boundaries</a></h2>
<ul>
<li>None at the crate level; backend may execute lazily/asynchronously but API is synchronous.</li>
</ul>
<h2 id="risks--notes-5"><a class="header" href="#risks--notes-5">Risks / notes</a></h2>
<ul>
<li>Sharing a model across threads is backend-dependent; Burn modules are typically <code>Send + Sync</code> for CPU/WGPU backends, but verify if using custom backends.</li>
</ul>
<h2 id="links-56"><a class="header" href="#links-56">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-models"><a class="header" href="#performance-notes-models">Performance Notes (models)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-5"><a class="header" href="#hot-paths-5">Hot paths</a></h2>
<ul>
<li>Forward passes of <code>TinyDet</code> / <code>BigDet</code>; cost scales with hidden size, depth, and max_boxes.</li>
<li><code>forward_multibox</code> does additional tensor math to reorder/clamp boxes.</li>
</ul>
<h2 id="allocation-patterns-5"><a class="header" href="#allocation-patterns-5">Allocation patterns</a></h2>
<ul>
<li>Layers are allocated at construction; forwards reuse layer weights.</li>
<li>Intermediate tensors allocated per forward (per Burn backend semantics); rely on backend caching/arena.</li>
</ul>
<h2 id="trait-objects-5"><a class="header" href="#trait-objects-5">Trait objects</a></h2>
<ul>
<li>None; generic over backend with static dispatch.</li>
</ul>
<h2 id="assumptions-5"><a class="header" href="#assumptions-5">Assumptions</a></h2>
<ul>
<li>Models are small; intended for lightweight inference. <code>BigDet</code> <code>max_boxes</code> multiplies output tensor size.</li>
</ul>
<h2 id="improvements-5"><a class="header" href="#improvements-5">Improvements</a></h2>
<ul>
<li>If using GPU, ensure backend feature is enabled to offload compute.</li>
<li>For CPU, consider reducing hidden/depth/max_boxes for faster demos, or fuse operations if profiling shows bottlenecks.</li>
</ul>
<h2 id="links-57"><a class="header" href="#links-57">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-models"><a class="header" href="#examples-models">Examples (models)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-build-and-run-tinydet-ndarray-backend"><a class="header" href="#1-build-and-run-tinydet-ndarray-backend">1) Build and run TinyDet (NdArray backend)</a></h2>
<pre><code class="language-rust ignore">use models::{TinyDet, TinyDetConfig};

fn main() {
    type B = burn::backend::ndarray::NdArrayBackend&lt;f32&gt;;
    let device = B::Device::default();
    let model = TinyDet::&lt;B&gt;::new(TinyDetConfig::default(), &amp;device);
    let input = burn::tensor::Tensor::&lt;B, 2&gt;::zeros([1, 4], &amp;device);
    let logits = model.forward(input);
    println!("logits shape = {:?}", logits.dims());
}</code></pre>
<h2 id="2-bigdet-multibox-forward"><a class="header" href="#2-bigdet-multibox-forward">2) BigDet multibox forward</a></h2>
<pre><code class="language-rust ignore">use models::{BigDet, BigDetConfig};

fn main() {
    type B = burn::backend::ndarray::NdArrayBackend&lt;f32&gt;;
    let device = B::Device::default();
    let cfg = BigDetConfig { max_boxes: 8, ..Default::default() };
    let model = BigDet::&lt;B&gt;::new(cfg, &amp;device);
    let input = burn::tensor::Tensor::&lt;B, 2&gt;::zeros([1, 4], &amp;device);
    let (boxes, scores) = model.forward_multibox(input);
    println!("boxes shape = {:?}, scores shape = {:?}", boxes.dims(), scores.dims());
}</code></pre>
<h2 id="links-58"><a class="header" href="#links-58">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-models"><a class="header" href="#design-review-models">Design Review (models)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-5"><a class="header" href="#whats-solid-5">What’s solid</a></h2>
<ul>
<li>Minimal configs and implementations; easy to read and extend.</li>
<li>Backend-generic design keeps CPU/GPU options open without changing APIs.</li>
<li><code>forward_multibox</code> enforces box ordering/clamping, improving downstream robustness.</li>
</ul>
<h2 id="risks--gaps-5"><a class="header" href="#risks--gaps-5">Risks / gaps</a></h2>
<ul>
<li>Models are very small; suitable as placeholders but may underfit real tasks.</li>
<li>No serialization/loading helpers here; relies on external tooling to persist checkpoints.</li>
<li><code>max_boxes</code> is fixed at construction; dynamic box counts require padding/truncation.</li>
</ul>
<h2 id="refactor-ideas-5"><a class="header" href="#refactor-ideas-5">Refactor ideas</a></h2>
<ul>
<li>Add simple load/save helpers (aligned with Burn recorders) to reduce boilerplate in consumers.</li>
<li>Consider exposing configurable activations/heads for experimentation.</li>
<li>Add basic tests/benchmarks to track perf/regressions as models evolve.</li>
</ul>
<h2 id="links-59"><a class="header" href="#links-59">Links</a></h2>
<ul>
<li>Source: <code>models/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="training-overview"><a class="header" href="#training-overview">training: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-6"><a class="header" href="#problem-statement-6">Problem statement</a></h2>
<p>Provide Burn-based training and evaluation pipelines for TinyDet/BigDet models using warehouse manifests produced by the CortenForge capture/ETL flow.</p>
<h2 id="scope-6"><a class="header" href="#scope-6">Scope</a></h2>
<ul>
<li>Training/eval CLIs (<code>train</code>, <code>eval</code>) driving <code>run_train</code>/<code>run_eval</code>.</li>
<li>Dataset loader from warehouse manifests to tensors; collate/loss/matching, optimizer/checkpoint I/O.</li>
<li>Feature flags for backends (<code>backend-ndarray</code> default, <code>backend-wgpu</code> opt-in) and model variants (<code>tinydet</code>/<code>bigdet</code>).</li>
</ul>
<h2 id="non-goals-6"><a class="header" href="#non-goals-6">Non-goals</a></h2>
<ul>
<li>No model definitions (comes from models crate).</li>
<li>No capture/ETL; assumes warehouse artifacts already exist.</li>
<li>No runtime/live inference; that’s in inference/vision_runtime.</li>
</ul>
<h2 id="who-should-use-it-6"><a class="header" href="#who-should-use-it-6">Who should use it</a></h2>
<ul>
<li>Users training/evaluating TinyDet/BigDet models from captured data.</li>
<li>Contributors adding losses/augmentations/schedulers or adjusting CLI flags.</li>
</ul>
<h2 id="links-60"><a class="header" href="#links-60">Links</a></h2>
<ul>
<li>Source: <code>training/src/lib.rs</code></li>
<li>Module: <code>training/src/dataset.rs</code></li>
<li>Module: <code>training/src/util.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-training</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="training-public-api"><a class="header" href="#training-public-api">training: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>DatasetConfig</td><td>struct</td><td>Config for dataset loading (paths, batch, splits)</td></tr>
<tr><td>RunSample</td><td>struct</td><td>Single sample from run/manifest</td></tr>
<tr><td><code>CollatedBatch&lt;B&gt;</code></td><td>struct</td><td>Batch of tensors for Burn backend B</td></tr>
<tr><td><code>collate&lt;B&gt;</code></td><td>fn</td><td>Collate run samples into a batch</td></tr>
<tr><td>TrainBackend</td><td>type</td><td>Backend alias (NdArray or WGPU)</td></tr>
<tr><td>TrainArgs</td><td>struct</td><td>CLI args for training</td></tr>
<tr><td>ModelKind</td><td>enum</td><td>Model variant selection (TinyDet/BigDet)</td></tr>
<tr><td>BackendKind</td><td>enum</td><td>Backend selection (NdArray/WGPU)</td></tr>
<tr><td>run_train</td><td>fn</td><td>Entry point to run training from args</td></tr>
<tr><td>load_tinydet_from_checkpoint</td><td>fn</td><td>Load TinyDet checkpoint</td></tr>
<tr><td>load_bigdet_from_checkpoint</td><td>fn</td><td>Load BigDet checkpoint</td></tr>
<tr><td>validate_backend_choice</td><td>fn</td><td>Validate backend choice</td></tr>
<tr><td>build_greedy_targets</td><td>fn</td><td>Build targets for training</td></tr>
<tr><td>Re-exports</td><td>re-export</td><td>TinyDet/BigDet configs and models from models crate</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>dataset, util</td></tr>
</tbody>
</table>
</div>
<h2 id="links-61"><a class="header" href="#links-61">Links</a></h2>
<ul>
<li>Source: <code>training/src/lib.rs</code></li>
<li>Module: <code>training/src/dataset.rs</code></li>
<li>Module: <code>training/src/util.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-training</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-training"><a class="header" href="#traits--generics-training">Traits &amp; Generics (training)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-6"><a class="header" href="#extensibility-traits-6">Extensibility traits</a></h2>
<ul>
<li>None defined; crate composes concrete functions and type aliases.</li>
</ul>
<h2 id="generics-and-bounds-6"><a class="header" href="#generics-and-bounds-6">Generics and bounds</a></h2>
<ul>
<li>Heavy use of the Burn <code>Backend</code> trait:
<ul>
<li><code>CollatedBatch&lt;B: Backend&gt;</code> and <code>collate&lt;B: Backend&gt;</code> produce tensors for an arbitrary backend.</li>
<li><code>TrainBackend</code> type alias switches between <code>burn_ndarray::NdArray&lt;f32&gt;</code> (default) and <code>burn_wgpu::Wgpu&lt;f32&gt;</code> under the <code>backend-wgpu</code> feature.</li>
</ul>
</li>
<li>No custom traits; functions operate on generic tensors but keep APIs concrete (<code>RunSample</code>, <code>DatasetConfig</code>).</li>
</ul>
<h2 id="design-notes-6"><a class="header" href="#design-notes-6">Design notes</a></h2>
<ul>
<li>Backend generic keeps training usable on CPU/GPU without changing call sites; callers pick backend via features.</li>
<li>No trait objects; compile-time backend selection aligns with Burn patterns.</li>
<li>If adding new data sources, prefer composing on <code>RunSample</code>/<code>collate</code> instead of introducing new traits unless multiple loaders must coexist.</li>
</ul>
<h2 id="links-62"><a class="header" href="#links-62">Links</a></h2>
<ul>
<li>Source: <code>training/src/dataset.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="training-module-map"><a class="header" href="#training-module-map">training: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>dataset</code>: Data types and collation for training batches.
<ul>
<li>Types: DatasetConfig, RunSample, CollatedBatch.</li>
<li>Function: <code>collate</code> (labels/images → tensors).</li>
</ul>
</li>
<li><code>util</code>: Training utilities and entrypoints.
<ul>
<li>Types: TrainArgs, ModelKind, BackendKind.</li>
<li>Functions: run_train, checkpoint loaders (TinyDet/BigDet), target builders.</li>
</ul>
</li>
<li><code>lib.rs</code>: Re-exports dataset/util, aliases backend/model types, pulls TinyDet/BigDet from models.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>dataset feeds util/run_train.</li>
<li>util constructs models from <code>models</code> and uses dataset loaders. Consumers are training bin and external callers.</li>
</ul>
<h2 id="links-63"><a class="header" href="#links-63">Links</a></h2>
<ul>
<li>Source: <code>training/src/lib.rs</code></li>
<li>Module: <code>training/src/dataset.rs</code></li>
<li>Module: <code>training/src/util.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="training-lifecycle"><a class="header" href="#training-lifecycle">training: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-6"><a class="header" href="#typical-usage-6">Typical usage</a></h2>
<ol>
<li>Prepare args/config and backend:
<pre><code class="language-rust ignore">let args = TrainArgs::parse(); // from clap
run_train(args)?;</code></pre>
</li>
<li>Loader builds dataset from warehouse manifest, splits runs, collates batches.</li>
<li>Model (TinyDet/BigDet) is constructed and trained; checkpoints written to output dir.</li>
</ol>
<h2 id="execution-flow-6"><a class="header" href="#execution-flow-6">Execution flow</a></h2>
<ul>
<li>CLI parses <code>TrainArgs</code> (model/backend selection, paths, output).</li>
<li>Dataset loader reads warehouse manifest, builds <code>DatasetConfig</code>, collates batches (NdArray default; WGPU if enabled).</li>
<li>Training loop runs forward/backward, logs metrics, saves checkpoints.</li>
<li>Optional eval uses similar path with eval bin.</li>
</ul>
<h2 id="notes-5"><a class="header" href="#notes-5">Notes</a></h2>
<ul>
<li>Backends/features: <code>backend-ndarray</code> default, <code>backend-wgpu</code> opt-in; <code>tinydet</code>/<code>bigdet</code> variants.</li>
</ul>
<h2 id="links-64"><a class="header" href="#links-64">Links</a></h2>
<ul>
<li>Source: <code>training/src/util.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-training"><a class="header" href="#error-model-training">Error Model (training)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-6"><a class="header" href="#errors-defined-6">Errors defined</a></h2>
<ul>
<li>Uses <code>anyhow::Result</code> for dataset loading/collation and training helpers; no custom error enums.</li>
</ul>
<h2 id="patterns-6"><a class="header" href="#patterns-6">Patterns</a></h2>
<ul>
<li><code>DatasetConfig::load</code> and <code>collate</code> propagate IO/image/serde errors via anyhow with context.</li>
<li>Collation bails on mixed image sizes or empty batches.</li>
<li>Training runner (<code>run_train</code>) surfaces errors from dataset/model setup (not shown here) via anyhow.</li>
</ul>
<h2 id="recoverability-6"><a class="header" href="#recoverability-6">Recoverability</a></h2>
<ul>
<li>Errors are caller-visible and typically fatal for the current run (invalid data, mismatched shapes).</li>
<li>No retry logic; callers should fix data or adjust configs and rerun.</li>
</ul>
<h2 id="ergonomics-6"><a class="header" href="#ergonomics-6">Ergonomics</a></h2>
<ul>
<li>anyhow keeps signatures simple for binaries; for library use, a typed error might improve matchability.</li>
<li>Errors include context (file paths, reasons) in message form; sufficient for CLIs.</li>
</ul>
<h2 id="links-65"><a class="header" href="#links-65">Links</a></h2>
<ul>
<li>Source: <code>training/src/dataset.rs</code></li>
<li>Source: <code>training/src/util.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-training"><a class="header" href="#ownership--concurrency-training">Ownership &amp; Concurrency (training)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-6"><a class="header" href="#ownership-model-6">Ownership model</a></h2>
<ul>
<li>Dataset samples (<code>RunSample</code>) and tensors are owned per batch; no global shared state.</li>
<li><code>CollatedBatch</code> owns tensors; caller controls their lifecycle.</li>
<li><code>TrainBackend</code> selection is compile-time; no runtime sharing across backends.</li>
</ul>
<h2 id="concurrency-6"><a class="header" href="#concurrency-6">Concurrency</a></h2>
<ul>
<li>No explicit threading in this crate; relies on Burn/backend for parallelism.</li>
<li>Functions consume slices/Vecs and allocate new buffers; thread safety is caller-dependent if processing batches in parallel.</li>
</ul>
<h2 id="borrowing-boundaries-6"><a class="header" href="#borrowing-boundaries-6">Borrowing boundaries</a></h2>
<ul>
<li><code>collate</code> borrows a slice of samples for the duration of collation, then produces owned tensors.</li>
<li>No retained borrows beyond the function call.</li>
</ul>
<h2 id="async-boundaries-6"><a class="header" href="#async-boundaries-6">Async boundaries</a></h2>
<ul>
<li>None; all operations are synchronous CPU-side, though WGPU backend may execute kernels asynchronously under the hood.</li>
</ul>
<h2 id="risks--notes-6"><a class="header" href="#risks--notes-6">Risks / notes</a></h2>
<ul>
<li>Concurrent collation on shared inputs would require callers to avoid mutating the same samples concurrently.</li>
</ul>
<h2 id="links-66"><a class="header" href="#links-66">Links</a></h2>
<ul>
<li>Source: <code>training/src/dataset.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-training"><a class="header" href="#performance-notes-training">Performance Notes (training)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-6"><a class="header" href="#hot-paths-6">Hot paths</a></h2>
<ul>
<li>Image decode and tensor construction in <code>collate</code>.</li>
<li>Tensor operations inside training loop (in <code>run_train</code>, not shown here); dominated by backend compute.</li>
</ul>
<h2 id="allocation-patterns-6"><a class="header" href="#allocation-patterns-6">Allocation patterns</a></h2>
<ul>
<li><code>collate</code> allocates image buffers (<code>Vec&lt;f32&gt;</code>) sized to batch * pixels * 3; reused per call scope, not pooled.</li>
<li>Features/boxes/masks allocated per batch; zero-filled buffers for boxes/masks.</li>
</ul>
<h2 id="trait-objects-6"><a class="header" href="#trait-objects-6">Trait objects</a></h2>
<ul>
<li>None; static dispatch via backend generics.</li>
</ul>
<h2 id="assumptions-6"><a class="header" href="#assumptions-6">Assumptions</a></h2>
<ul>
<li>Batch images must share dimensions; otherwise collation bails. No dynamic resizing, so preprocessed datasets are assumed.</li>
<li>CPU path may be slow for large images/batches; WGPU backend should be used for acceleration.</li>
</ul>
<h2 id="improvements-6"><a class="header" href="#improvements-6">Improvements</a></h2>
<ul>
<li>Add buffer pooling or use <code>Vec::with_capacity</code> reuse between batches if integrating into a long-running trainer.</li>
<li>Parallelize image decode/loading across batches if IO becomes the bottleneck.</li>
</ul>
<h2 id="links-67"><a class="header" href="#links-67">Links</a></h2>
<ul>
<li>Source: <code>training/src/dataset.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-training"><a class="header" href="#examples-training">Examples (training)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-load-dataset-samples"><a class="header" href="#1-load-dataset-samples">1) Load dataset samples</a></h2>
<pre><code class="language-rust ignore">use training::{DatasetConfig};

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let cfg = DatasetConfig {
        root: "assets/datasets/captures/run_00001".into(),
        labels_subdir: "labels".into(),
        images_subdir: "images".into(),
    };
    let samples = cfg.load()?;
    println!("loaded {} samples", samples.len());
    Ok(())
}</code></pre>
<h2 id="2-collate-a-batch-ndarray-backend"><a class="header" href="#2-collate-a-batch-ndarray-backend">2) Collate a batch (NdArray backend)</a></h2>
<pre><code class="language-rust ignore">use training::{DatasetConfig, RunSample, collate, TrainBackend};

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let cfg = DatasetConfig {
        root: "assets/datasets/captures/run_00001".into(),
        labels_subdir: "labels".into(),
        images_subdir: "images".into(),
    };
    let samples = cfg.load()?;
    let batch = collate::&lt;TrainBackend&gt;(&amp;samples[..2], 16)?;
    println!("batch images shape = {:?}", batch.images.dims());
    Ok(())
}</code></pre>
<h2 id="3-run-training-high-level"><a class="header" href="#3-run-training-high-level">3) Run training (high level)</a></h2>
<pre><code class="language-rust ignore">use clap::Parser;
use training::util::{run_train, TrainArgs};

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let args = TrainArgs::parse();
    run_train(args)?;
    Ok(())
}</code></pre>
<h2 id="links-68"><a class="header" href="#links-68">Links</a></h2>
<ul>
<li>Source: <code>training/src/dataset.rs</code></li>
<li>Source: <code>training/src/util.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-training"><a class="header" href="#design-review-training">Design Review (training)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-6"><a class="header" href="#whats-solid-6">What’s solid</a></h2>
<ul>
<li>Straightforward dataset loading/collation with clear expectations (same image size per batch).</li>
<li>Backend alias keeps code portable across CPU/GPU.</li>
<li>Uses shared data contracts for validation, avoiding divergence from runtime schemas.</li>
</ul>
<h2 id="risks--gaps-6"><a class="header" href="#risks--gaps-6">Risks / gaps</a></h2>
<ul>
<li>Uses anyhow for all errors; limited ability to discriminate error kinds programmatically.</li>
<li>Collation assumes uniform dimensions; no auto-resize or padding path for mixed data.</li>
<li>No built-in logging/metrics around skips/failures during load/collate.</li>
</ul>
<h2 id="refactor-ideas-6"><a class="header" href="#refactor-ideas-6">Refactor ideas</a></h2>
<ul>
<li>Introduce typed errors for data issues (missing files, shape mismatch) to allow better handling/reporting.</li>
<li>Add optional resize/pad strategy in collate for mixed-size datasets.</li>
<li>Add basic instrumentation (counts, timing) around collation to spot bottlenecks.</li>
</ul>
<h2 id="links-69"><a class="header" href="#links-69">Links</a></h2>
<ul>
<li>Source: <code>training/src/dataset.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inference-overview"><a class="header" href="#inference-overview">inference: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-7"><a class="header" href="#problem-statement-7">Problem statement</a></h2>
<p>Provide a detector factory that loads model checkpoints (TinyDet/BigDet via models) and returns a <code>Detector</code> implementation for runtime/tools, with a heuristic fallback when weights are absent.</p>
<h2 id="scope-7"><a class="header" href="#scope-7">Scope</a></h2>
<ul>
<li>Factory API to load checkpoints and build Burn-backed detectors.</li>
<li>Heuristic detector fallback for cases without weights.</li>
<li>Feature flags for backends (<code>backend-ndarray</code> default, <code>backend-wgpu</code> opt-in) and model variants (<code>tinydet</code>/<code>bigdet</code>).</li>
</ul>
<h2 id="non-goals-7"><a class="header" href="#non-goals-7">Non-goals</a></h2>
<ul>
<li>No capture/runtime scheduling (handled by vision_runtime).</li>
<li>No model definitions (from models) or training (from training).</li>
<li>No app-specific detector logic; keeps interface generic.</li>
</ul>
<h2 id="who-should-use-it-7"><a class="header" href="#who-should-use-it-7">Who should use it</a></h2>
<ul>
<li>Runtime/inference plugins (vision_runtime) needing a detector handle.</li>
<li>Tools performing offline inference (e.g., single_infer) that need a factory.</li>
<li>Contributors adding backends or selection logic.</li>
</ul>
<h2 id="links-70"><a class="header" href="#links-70">Links</a></h2>
<ul>
<li>Source: <code>inference/src/lib.rs</code></li>
<li>Module: <code>inference/src/factory.rs</code></li>
<li>Module: <code>inference/src/plugin.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-inference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inference-public-api"><a class="header" href="#inference-public-api">inference: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>InferenceFactory</td><td>struct</td><td>Loads checkpoints and builds detectors</td></tr>
<tr><td>InferenceThresholds</td><td>struct</td><td>Thresholds for inference</td></tr>
<tr><td>InferencePlugin</td><td>struct</td><td>Bevy plugin to integrate inference state</td></tr>
<tr><td>InferenceState</td><td>struct</td><td>Tracks inference state (plugin)</td></tr>
<tr><td>InferenceBackend</td><td>type</td><td>Backend alias (NdArray or WGPU)</td></tr>
<tr><td><code>InferenceModel&lt;B&gt;</code></td><td>type</td><td>Model alias (TinyDet/BigDet) for backend B</td></tr>
<tr><td>InferenceModelConfig</td><td>type</td><td>Model config alias</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>factory, plugin, prelude</td></tr>
<tr><td>Re-exports</td><td>re-export</td><td>InferenceFactory, InferenceThresholds, InferencePlugin</td></tr>
</tbody>
</table>
</div>
<h2 id="links-71"><a class="header" href="#links-71">Links</a></h2>
<ul>
<li>Source: <code>inference/src/lib.rs</code></li>
<li>Module: <code>inference/src/factory.rs</code></li>
<li>Module: <code>inference/src/plugin.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-inference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-inference"><a class="header" href="#traits--generics-inference">Traits &amp; Generics (inference)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-7"><a class="header" href="#extensibility-traits-7">Extensibility traits</a></h2>
<ul>
<li>None defined directly; crate consumes <code>vision_core::Detector</code> and provides concrete implementations.</li>
</ul>
<h2 id="generics-and-bounds-7"><a class="header" href="#generics-and-bounds-7">Generics and bounds</a></h2>
<ul>
<li>Backend selection via type alias <code>InferenceBackend</code> (NdArray by default, WGPU when feature enabled).</li>
<li>Model selection via aliases: <code>InferenceModel&lt;B&gt;</code> / <code>InferenceModelConfig</code> pick <code>models::TinyDet</code> or <code>models::BigDet</code> based on the <code>bigdet</code> feature. Both are generic over Burn <code>Backend</code>.</li>
<li><code>InferenceFactory</code> returns <code>Box&lt;dyn vision_core::Detector + Send + Sync&gt;</code> (trait object) so callers don’t need to name the concrete detector.</li>
</ul>
<h2 id="design-notes-7"><a class="header" href="#design-notes-7">Design notes</a></h2>
<ul>
<li>Feature-gated model/backend keeps the public API stable while allowing different compile-time choices.</li>
<li>Factory hides concrete detector types behind a trait object to allow heuristic fallback vs. Burn-backed detector without leaking types.</li>
<li>If additional detectors are added, extend the factory (or add a new trait) but keep the trait-object boundary for runtime swapping.</li>
</ul>
<h2 id="links-72"><a class="header" href="#links-72">Links</a></h2>
<ul>
<li>Source: <code>inference/src/factory.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inference-module-map"><a class="header" href="#inference-module-map">inference: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>factory</code>: InferenceFactory, InferenceThresholds, logic to load checkpoints and build detectors (Burn or heuristic), backend/model selection.</li>
<li><code>plugin</code>: InferencePlugin and InferenceState for Bevy integration.</li>
<li><code>prelude</code>: Convenience re-exports.</li>
<li><code>lib.rs</code>: Re-exports factory/plugin/prelude and backend/model aliases.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>factory depends on models and burn.</li>
<li>plugin integrates with sim_core mode sets.</li>
<li>consumers (runtime/tools) use factory and/or plugin.</li>
</ul>
<h2 id="links-73"><a class="header" href="#links-73">Links</a></h2>
<ul>
<li>Source: <code>inference/src/lib.rs</code></li>
<li>Module: <code>inference/src/factory.rs</code></li>
<li>Module: <code>inference/src/plugin.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inference-lifecycle"><a class="header" href="#inference-lifecycle">inference: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-7"><a class="header" href="#typical-usage-7">Typical usage</a></h2>
<ol>
<li>Construct factory and thresholds:
<pre><code class="language-rust ignore">let factory = InferenceFactory;
let thresholds = InferenceThresholds { obj_thresh, iou_thresh };
let detector = factory.build(thresholds, weights.as_deref());</code></pre>
</li>
<li>Provide detector/thresholds to runtime/tools (e.g., insert into Bevy resources for vision_runtime, or use directly in single-image inference).</li>
</ol>
<h2 id="execution-flow-7"><a class="header" href="#execution-flow-7">Execution flow</a></h2>
<ul>
<li>Factory loads model checkpoint (TinyDet/BigDet) via models; picks backend based on features (<code>backend-ndarray</code> default, <code>backend-wgpu</code> opt-in).</li>
<li>If load fails/no weights, returns heuristic detector.</li>
<li>Runtime/plugins (vision_runtime) schedule detector on captured frames; tools may invoke detector on images directly.</li>
</ul>
<h2 id="notes-6"><a class="header" href="#notes-6">Notes</a></h2>
<ul>
<li>Stateless beyond factory/detector instances; lifecycle managed by caller.</li>
</ul>
<h2 id="links-74"><a class="header" href="#links-74">Links</a></h2>
<ul>
<li>Source: <code>inference/src/factory.rs</code></li>
<li>Source: <code>inference/src/plugin.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-inference"><a class="header" href="#error-model-inference">Error Model (inference)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-7"><a class="header" href="#errors-defined-7">Errors defined</a></h2>
<ul>
<li>Uses existing error channels; no custom error enums.</li>
<li>Factory load path:
<ul>
<li><code>InferenceFactory::try_load_burn_detector</code> returns <code>Option&lt;Box&lt;Detector&gt;&gt;</code>; errors (missing weights, load failures) are logged (<code>eprintln!</code>) and fall back to heuristic.</li>
</ul>
</li>
<li>Tests rely on detector.detect not panicking.</li>
</ul>
<h2 id="patterns-7"><a class="header" href="#patterns-7">Patterns</a></h2>
<ul>
<li>Heuristic fallback on any checkpoint issue; model load errors are not propagated.</li>
<li>Mutex poisoning on detector lock would panic; otherwise infallible detect path.</li>
</ul>
<h2 id="recoverability-7"><a class="header" href="#recoverability-7">Recoverability</a></h2>
<ul>
<li>Fully recoverable: absence/bad weights yields heuristic detector with a log message.</li>
<li>No structured error for callers to differentiate failure reasons.</li>
</ul>
<h2 id="ergonomics-7"><a class="header" href="#ergonomics-7">Ergonomics</a></h2>
<ul>
<li>Silent (logged) fallback keeps CLI usable but hides error specifics; consider returning a typed error or result alongside the detector when model availability matters.</li>
</ul>
<h2 id="links-75"><a class="header" href="#links-75">Links</a></h2>
<ul>
<li>Source: <code>inference/src/factory.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-inference"><a class="header" href="#ownership--concurrency-inference">Ownership &amp; Concurrency (inference)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-7"><a class="header" href="#ownership-model-7">Ownership model</a></h2>
<ul>
<li><code>InferenceFactory</code> produces boxed detectors; ownership is transferred to callers.</li>
<li>Burn-backed detector holds <code>Arc&lt;Mutex&lt;InferenceModel&lt;InferenceBackend&gt;&gt;&gt;</code> to share the model between calls.</li>
<li>Heuristic detector owns simple fields; no sharing.</li>
</ul>
<h2 id="concurrency-7"><a class="header" href="#concurrency-7">Concurrency</a></h2>
<ul>
<li>Model access synchronized via <code>Mutex</code>; per-detect lock to guard forward pass. Suitable for multi-threaded use but serializes inference calls.</li>
<li><code>Arc</code> allows detector clones (if added) to share the same model; current code boxes a single detector.</li>
</ul>
<h2 id="borrowing-boundaries-7"><a class="header" href="#borrowing-boundaries-7">Borrowing boundaries</a></h2>
<ul>
<li>Detector methods take <code>&amp;mut self</code>; combined with mutex, they serialize access. No long-lived borrows are held.</li>
</ul>
<h2 id="async-boundaries-7"><a class="header" href="#async-boundaries-7">Async boundaries</a></h2>
<ul>
<li>None in this crate; async scheduling is handled in <code>vision_runtime</code>.</li>
</ul>
<h2 id="risks--notes-7"><a class="header" href="#risks--notes-7">Risks / notes</a></h2>
<ul>
<li>Mutex poisoning would panic; consider handling if long-running use cases matter.</li>
<li>If high-throughput is needed, consider removing the mutex by using cloneable models or separate detectors per thread.</li>
</ul>
<h2 id="links-76"><a class="header" href="#links-76">Links</a></h2>
<ul>
<li>Source: <code>inference/src/factory.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-inference"><a class="header" href="#performance-notes-inference">Performance Notes (inference)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-7"><a class="header" href="#hot-paths-7">Hot paths</a></h2>
<ul>
<li>Model forward pass in <code>BurnTinyDetDetector::detect</code>.</li>
<li>Frame preprocessing (<code>frame_to_tensor</code>) computes RGB means/aspect ratio; lightweight.</li>
</ul>
<h2 id="allocation-patterns-7"><a class="header" href="#allocation-patterns-7">Allocation patterns</a></h2>
<ul>
<li>Each detect builds a small <code>TensorData</code> (shape [1,4]) and copies scores out of the output tensor.</li>
<li>Uses <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> around the model; contention can serialize calls.</li>
<li>Fallback detector does minimal work.</li>
</ul>
<h2 id="trait-objects-7"><a class="header" href="#trait-objects-7">Trait objects</a></h2>
<ul>
<li>Detector is a trait object; dynamic dispatch negligible compared to model compute.</li>
</ul>
<h2 id="assumptions-7"><a class="header" href="#assumptions-7">Assumptions</a></h2>
<ul>
<li>Single-threaded inference by default due to mutex guard; designed for low-QPS use.</li>
<li>Score extraction clones into <code>Vec&lt;f32&gt;</code>; acceptable for small outputs.</li>
</ul>
<h2 id="improvements-7"><a class="header" href="#improvements-7">Improvements</a></h2>
<ul>
<li>Remove/relax mutex if using per-thread detectors for higher throughput.</li>
<li>Cache/reuse input/output buffers if detecting many frames in a tight loop.</li>
</ul>
<h2 id="links-77"><a class="header" href="#links-77">Links</a></h2>
<ul>
<li>Source: <code>inference/src/factory.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-inference"><a class="header" href="#examples-inference">Examples (inference)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-heuristic-detector-fallback"><a class="header" href="#1-heuristic-detector-fallback">1) Heuristic detector fallback</a></h2>
<pre><code class="language-rust ignore">use inference::{InferenceFactory, InferenceThresholds};

fn main() {
    let factory = InferenceFactory;
    let mut detector = factory.build(InferenceThresholds::default(), None);
    let frame = vision_core::interfaces::Frame {
        id: 1,
        timestamp: 0.0,
        rgba: None,
        size: (640, 480),
        path: None,
    };
    let result = detector.detect(&amp;frame);
    println!("conf={:.2} positive={}", result.confidence, result.positive);
}</code></pre>
<h2 id="2-load-burn-checkpoint-if-available"><a class="header" href="#2-load-burn-checkpoint-if-available">2) Load Burn checkpoint (if available)</a></h2>
<pre><code class="language-rust ignore">use std::path::Path;
use inference::{InferenceFactory, InferenceThresholds};

fn main() {
    let factory = InferenceFactory;
    let weights = Path::new("artifacts/checkpoints/tinydet.bin");
    let mut detector = factory.build(InferenceThresholds { obj_thresh: 0.5, iou_thresh: 0.5 }, Some(weights));
    let frame = vision_core::interfaces::Frame {
        id: 2,
        timestamp: 0.0,
        rgba: None,
        size: (640, 480),
        path: None,
    };
    let result = detector.detect(&amp;frame);
    println!("boxes={}, scores={}", result.boxes.len(), result.scores.len());
}</code></pre>
<h2 id="3-adjust-thresholds-at-construction"><a class="header" href="#3-adjust-thresholds-at-construction">3) Adjust thresholds at construction</a></h2>
<pre><code class="language-rust ignore">use inference::{InferenceFactory, InferenceThresholds};

fn main() {
    let factory = InferenceFactory;
    let mut detector = factory.build(
        InferenceThresholds { obj_thresh: 0.8, iou_thresh: 0.6 },
        None,
    );
    // detector uses obj_thresh internally for confidence check
    let _ = detector;
}</code></pre>
<h2 id="links-78"><a class="header" href="#links-78">Links</a></h2>
<ul>
<li>Source: <code>inference/src/factory.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-inference"><a class="header" href="#design-review-inference">Design Review (inference)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-7"><a class="header" href="#whats-solid-7">What’s solid</a></h2>
<ul>
<li>Clean factory abstraction that hides detector choice (heuristic vs. Burn) behind one API.</li>
<li>Feature-gated backend/model selection keeps surface area stable.</li>
<li>Minimal preprocessing keeps detector integration simple.</li>
</ul>
<h2 id="risks--gaps-7"><a class="header" href="#risks--gaps-7">Risks / gaps</a></h2>
<ul>
<li>Mutex-guarded model serializes inference; not suitable for high-throughput unless duplicated per thread.</li>
<li>Error handling is implicit (logs + heuristic fallback); hard for callers to detect/model-load failures programmatically.</li>
<li>Preprocessing is extremely naive (RGB mean + aspect ratio); may not match trained model expectations for real data.</li>
</ul>
<h2 id="refactor-ideas-7"><a class="header" href="#refactor-ideas-7">Refactor ideas</a></h2>
<ul>
<li>Return a structured result from factory load (e.g., enum with “LoadedBurn”/“Fallback”) to allow callers to act on failures.</li>
<li>Add configurable preprocessing pipeline to align with training data; consider using <code>capture_utils</code>/<code>burn_dataset</code> transforms.</li>
<li>Provide an option to create per-thread detectors to avoid mutex contention, or use a thread-safe queue of detectors.</li>
</ul>
<h2 id="links-79"><a class="header" href="#links-79">Links</a></h2>
<ul>
<li>Source: <code>inference/src/factory.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli_support-overview"><a class="header" href="#cli_support-overview">cli_support: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-8"><a class="header" href="#problem-statement-8">Problem statement</a></h2>
<p>Provide shared CLI argument parsing and helper utilities for CortenForge tools/apps (capture, warehouse, seeds, thresholds), reducing duplication across bins.</p>
<h2 id="scope-8"><a class="header" href="#scope-8">Scope</a></h2>
<ul>
<li>Common CLI structs/parsers for capture/warehouse/config options.</li>
<li>Optional Bevy resource integration (<code>bevy</code>, <code>bevy-resource</code> features).</li>
<li>Reusable helpers for tools and app CLIs.</li>
</ul>
<h2 id="non-goals-8"><a class="header" href="#non-goals-8">Non-goals</a></h2>
<ul>
<li>No runtime logic or capture/ETL implementation; only CLI plumbing.</li>
<li>No app-specific commands; keep generic to substrate tooling.</li>
</ul>
<h2 id="who-should-use-it-8"><a class="header" href="#who-should-use-it-8">Who should use it</a></h2>
<ul>
<li>Tooling crates (cortenforge-tools; crate <code>cortenforge_tools</code>) and any app binaries needing consistent args.</li>
<li>Contributors adding/adjusting shared CLI options for the stack.</li>
</ul>
<h2 id="links-80"><a class="header" href="#links-80">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-cli-support</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli_support-public-api"><a class="header" href="#cli_support-public-api">cli_support: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>ThresholdOpts</td><td>struct</td><td>CLI thresholds for inference/detection</td></tr>
<tr><td>WeightsOpts</td><td>struct</td><td>CLI weights paths/options</td></tr>
<tr><td>CaptureOutputArgs</td><td>struct</td><td>CLI args for capture outputs</td></tr>
<tr><td>CaptureOutputOpts</td><td>struct</td><td>Output options for capture</td></tr>
<tr><td>WarehouseOutputArgs</td><td>struct</td><td>CLI args for warehouse outputs</td></tr>
<tr><td>WarehouseOutputOpts</td><td>struct</td><td>Output options for warehouse</td></tr>
<tr><td>WgpuEnvHints</td><td>struct</td><td>Hints for WGPU environment setup</td></tr>
<tr><td>SeedState</td><td>struct</td><td>Seed state container</td></tr>
<tr><td>resolve_seed</td><td>fn</td><td>Resolve seed from CLI input</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>common, seed</td></tr>
</tbody>
</table>
</div>
<h2 id="links-81"><a class="header" href="#links-81">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-cli-support</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-cli_support"><a class="header" href="#traits--generics-cli_support">Traits &amp; Generics (cli_support)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-8"><a class="header" href="#extensibility-traits-8">Extensibility traits</a></h2>
<ul>
<li>None; crate provides plain structs/helpers for CLI configuration.</li>
</ul>
<h2 id="generics-and-bounds-8"><a class="header" href="#generics-and-bounds-8">Generics and bounds</a></h2>
<ul>
<li>All structs are concrete; no generic parameters or custom traits.</li>
<li>Clap derives (<code>Args</code>) used where CLI parsing is needed (<code>CaptureOutputArgs</code>, <code>WarehouseOutputArgs</code>).</li>
<li>SeedState optionally derives <code>bevy::Resource</code> behind <code>bevy-resource</code> feature for reuse in Bevy apps.</li>
</ul>
<h2 id="design-notes-8"><a class="header" href="#design-notes-8">Design notes</a></h2>
<ul>
<li>Keeping everything concrete avoids trait-object noise in binaries; consumers convert <code>Args</code> → internal opts via <code>From</code>.</li>
<li>Feature-gated Bevy derive keeps default dependency surface minimal.</li>
</ul>
<h2 id="links-82"><a class="header" href="#links-82">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli_support-module-map"><a class="header" href="#cli_support-module-map">cli_support: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>common</code>: Shared CLI option structs (thresholds, weights, capture/warehouse outputs, WgpuEnvHints).</li>
<li><code>seed</code>: SeedState helper and resolve_seed function.</li>
<li><code>lib.rs</code>: Re-exports common/seed modules.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>used by tooling/apps for consistent CLI parsing.</li>
<li>optional Bevy resource features extend usage.</li>
</ul>
<h2 id="links-83"><a class="header" href="#links-83">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli_support-lifecycle"><a class="header" href="#cli_support-lifecycle">cli_support: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-8"><a class="header" href="#typical-usage-8">Typical usage</a></h2>
<ul>
<li>Define CLI structs in tools/apps using provided opts:
<pre><code class="language-rust ignore">#[derive(clap::Parser)]
struct Args {
    #[clap(flatten)]
    capture: CaptureOutputArgs,
    #[clap(flatten)]
    warehouse: WarehouseOutputArgs,
    #[clap(long)]
    seed: Option&lt;u64&gt;,
}
let args = Args::parse();
let capture_opts: CaptureOutputOpts = (&amp;args.capture).into();
let warehouse_opts: WarehouseOutputOpts = (&amp;args.warehouse).into();</code></pre>
</li>
<li>Resolve seeds:
<pre><code class="language-rust ignore">let seed = resolve_seed(args.seed);</code></pre>
</li>
<li>Pass parsed options into tooling/runtime setup.</li>
</ul>
<h2 id="execution-flow-8"><a class="header" href="#execution-flow-8">Execution flow</a></h2>
<ul>
<li>CLI derives parse args; <code>flatten</code>ed structs supply common options.</li>
<li>Optional Bevy integration if <code>bevy-resource</code> feature is used to insert resources.</li>
<li>Caller uses parsed values to configure capture/warehouse/weights/thresholds.</li>
</ul>
<h2 id="notes-7"><a class="header" href="#notes-7">Notes</a></h2>
<ul>
<li>Stateless; lifecycle ends after parsing/using args. Features enable Bevy resource adapters if needed.</li>
</ul>
<h2 id="links-84"><a class="header" href="#links-84">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-cli_support"><a class="header" href="#error-model-cli_support">Error Model (cli_support)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-8"><a class="header" href="#errors-defined-8">Errors defined</a></h2>
<ul>
<li>None; structs are pure data holders. No functions return <code>Result</code>.</li>
</ul>
<h2 id="patterns-8"><a class="header" href="#patterns-8">Patterns</a></h2>
<ul>
<li>Error handling is expected in consumers (CLI binaries) when converting/validating options.</li>
<li><code>resolve_seed</code> falls back silently if env parsing fails; no errors surfaced.</li>
</ul>
<h2 id="recoverability-8"><a class="header" href="#recoverability-8">Recoverability</a></h2>
<ul>
<li>Fully up to callers; this crate never fails.</li>
</ul>
<h2 id="ergonomics-8"><a class="header" href="#ergonomics-8">Ergonomics</a></h2>
<ul>
<li>Simplicity suits CLI args; add validation in callers if stricter invariants are needed (e.g., threshold ranges).</li>
</ul>
<h2 id="links-85"><a class="header" href="#links-85">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-cli_support"><a class="header" href="#ownership--concurrency-cli_support">Ownership &amp; Concurrency (cli_support)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-8"><a class="header" href="#ownership-model-8">Ownership model</a></h2>
<ul>
<li>Pure data structs (opts/args/seeds); no shared mutable state.</li>
<li><code>SeedState</code> holds a <code>u64</code> by value; ownership is straightforward.</li>
</ul>
<h2 id="concurrency-8"><a class="header" href="#concurrency-8">Concurrency</a></h2>
<ul>
<li>No threading/async; types are <code>Send + Sync</code> by default due to primitive fields. Safe to share if callers choose.</li>
</ul>
<h2 id="borrowing-boundaries-8"><a class="header" href="#borrowing-boundaries-8">Borrowing boundaries</a></h2>
<ul>
<li>All options are owned. Conversion <code>From&lt;&amp;CaptureOutputArgs&gt; for CaptureOutputOpts</code> clones paths as needed.</li>
</ul>
<h2 id="async-boundaries-8"><a class="header" href="#async-boundaries-8">Async boundaries</a></h2>
<ul>
<li>None; callers can use in async contexts without restriction.</li>
</ul>
<h2 id="risks--notes-8"><a class="header" href="#risks--notes-8">Risks / notes</a></h2>
<ul>
<li>None; concurrency concerns are entirely caller-managed.</li>
</ul>
<h2 id="links-86"><a class="header" href="#links-86">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-cli_support"><a class="header" href="#performance-notes-cli_support">Performance Notes (cli_support)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-8"><a class="header" href="#hot-paths-8">Hot paths</a></h2>
<ul>
<li>None; crate is configuration/data only.</li>
</ul>
<h2 id="allocation-patterns-8"><a class="header" href="#allocation-patterns-8">Allocation patterns</a></h2>
<ul>
<li>Minimal: allocates paths/strings when parsing CLI args or constructing opts.</li>
</ul>
<h2 id="trait-objects-8"><a class="header" href="#trait-objects-8">Trait objects</a></h2>
<ul>
<li>None.</li>
</ul>
<h2 id="assumptions-8"><a class="header" href="#assumptions-8">Assumptions</a></h2>
<ul>
<li>Overhead is negligible; performance driven by consumer binaries.</li>
</ul>
<h2 id="links-87"><a class="header" href="#links-87">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-cli_support"><a class="header" href="#examples-cli_support">Examples (cli_support)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-parse-capture-args-with-clap-and-convert"><a class="header" href="#1-parse-capture-args-with-clap-and-convert">1) Parse capture args with clap and convert</a></h2>
<pre><code class="language-rust ignore">use clap::Parser;
use cli_support::{CaptureOutputArgs, CaptureOutputOpts};

#[derive(Parser)]
struct Args {
    #[command(flatten)]
    capture: CaptureOutputArgs,
}

fn main() {
    let args = Args::parse();
    let opts: CaptureOutputOpts = (&amp;args.capture).into();
    println!("output_root={:?}", opts.output_root);
}</code></pre>
<h2 id="2-apply-wgpu-env-hints"><a class="header" href="#2-apply-wgpu-env-hints">2) Apply WGPU env hints</a></h2>
<pre><code class="language-rust ignore">use cli_support::WgpuEnvHints;

fn main() {
    let hints = WgpuEnvHints {
        backend: Some("vulkan".into()),
        adapter_name: Some("NVIDIA".into()),
        power_pref: Some("high-performance".into()),
        rust_log: Some("info".into()),
    };
    for (k, v) in [
        ("WGPU_BACKEND", hints.backend),
        ("WGPU_ADAPTER_NAME", hints.adapter_name),
        ("WGPU_POWER_PREF", hints.power_pref),
        ("RUST_LOG", hints.rust_log),
    ] {
        if let Some(val) = v {
            std::env::set_var(k, val);
        }
    }
}</code></pre>
<h2 id="3-resolve-seed"><a class="header" href="#3-resolve-seed">3) Resolve seed</a></h2>
<pre><code class="language-rust ignore">use cli_support::resolve_seed;

fn main() {
    let seed = resolve_seed(None);
    println!("seed = {}", seed);
}</code></pre>
<h2 id="links-88"><a class="header" href="#links-88">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-cli_support"><a class="header" href="#design-review-cli_support">Design Review (cli_support)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-8"><a class="header" href="#whats-solid-8">What’s solid</a></h2>
<ul>
<li>Concise, concrete option structs; minimal deps (clap optional).</li>
<li>Clear separation between CLI-facing <code>Args</code> and internal <code>Opts</code>.</li>
<li>Feature-gated Bevy derive keeps the default lightweight.</li>
</ul>
<h2 id="risks--gaps-8"><a class="header" href="#risks--gaps-8">Risks / gaps</a></h2>
<ul>
<li>No validation (e.g., threshold ranges, paths existing); relies entirely on callers.</li>
<li>Env hint struct is inert; consumers must remember to apply it.</li>
</ul>
<h2 id="refactor-ideas-8"><a class="header" href="#refactor-ideas-8">Refactor ideas</a></h2>
<ul>
<li>Add light validation helpers (threshold clamping, path existence) to reduce duplication in consumers.</li>
<li>Provide convenience functions to apply <code>WgpuEnvHints</code> to env/logging to avoid repeat boilerplate.</li>
</ul>
<h2 id="links-89"><a class="header" href="#links-89">Links</a></h2>
<ul>
<li>Source: <code>crates/cli_support/src/common.rs</code></li>
<li>Source: <code>crates/cli_support/src/seed.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="burn_dataset-overview"><a class="header" href="#burn_dataset-overview">burn_dataset: Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-9"><a class="header" href="#problem-statement-9">Problem statement</a></h2>
<p>Provide dataset loading, splitting, and Burn-compatible batching utilities for CortenForge, consuming capture/warehouse artifacts defined by data_contracts.</p>
<h2 id="scope-9"><a class="header" href="#scope-9">Scope</a></h2>
<ul>
<li>Dataset loader from capture/warehouse manifests to Burn tensors.</li>
<li>Splitting, batching, and optional mmap/rayon support via features.</li>
<li><code>burn_runtime</code> feature enables Burn integrations (burn + burn-ndarray).</li>
</ul>
<h2 id="non-goals-9"><a class="header" href="#non-goals-9">Non-goals</a></h2>
<ul>
<li>No model definitions or training loop; feeds training crate.</li>
<li>No capture/ETL generation; assumes artifacts exist.</li>
<li>No app-specific dataset logic beyond generic loaders.</li>
</ul>
<h2 id="who-should-use-it-9"><a class="header" href="#who-should-use-it-9">Who should use it</a></h2>
<ul>
<li>Training pipelines needing to load data into Burn.</li>
<li>Tools that need to inspect or batch warehouse data.</li>
<li>Contributors extending loader options or backend support.</li>
</ul>
<h2 id="links-90"><a class="header" href="#links-90">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-burn-dataset</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="burn_dataset-public-api"><a class="header" href="#burn_dataset-public-api">burn_dataset: Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>DatasetResult&lt;T&gt;</code></td><td>type</td><td>Result alias with BurnDatasetError</td></tr>
<tr><td>BurnDatasetError</td><td>enum</td><td>Error variants for dataset ops</td></tr>
<tr><td>DatasetSample</td><td>struct</td><td>Single sample from dataset</td></tr>
<tr><td>DatasetConfig</td><td>struct</td><td>Config for dataset loading/splitting</td></tr>
<tr><td>ResizeMode</td><td>enum</td><td>Resize behavior for images</td></tr>
<tr><td>SampleIndex</td><td>struct</td><td>Index of samples in runs</td></tr>
<tr><td>CacheableTransformConfig</td><td>struct</td><td>Config for caching transforms</td></tr>
<tr><td>TransformPipeline</td><td>struct</td><td>Pipeline of transforms</td></tr>
<tr><td>TransformPipelineBuilder</td><td>struct</td><td>Builder for transform pipelines</td></tr>
<tr><td>RunSummary</td><td>struct</td><td>Summary of a run</td></tr>
<tr><td>DatasetSummary</td><td>struct</td><td>Summary across runs</td></tr>
<tr><td>ValidationOutcome</td><td>enum</td><td>Validation result</td></tr>
<tr><td>ValidationThresholds</td><td>struct</td><td>Thresholds for validation</td></tr>
<tr><td>ValidationReport</td><td>struct</td><td>Validation report</td></tr>
<tr><td>ShardMetadata</td><td>struct</td><td>Metadata for warehouse shard</td></tr>
<tr><td>ShardDType</td><td>enum</td><td>Shard data type</td></tr>
<tr><td>Endianness</td><td>enum</td><td>Endianness for shard data</td></tr>
<tr><td>WarehouseStoreMode</td><td>enum</td><td>Storage mode for warehouse</td></tr>
<tr><td>WarehouseManifest</td><td>struct</td><td>Manifest for warehouse shards</td></tr>
<tr><td><code>BurnBatch&lt;B&gt;</code></td><td>struct</td><td>Batch for Burn backend B</td></tr>
<tr><td>BatchIter</td><td>struct</td><td>Iterator over batches</td></tr>
<tr><td>WarehouseBatchIter</td><td>struct</td><td>Iterator over warehouse batches</td></tr>
<tr><td>WarehouseShardStore</td><td>trait</td><td>Interface for shard storage backends</td></tr>
<tr><td>WarehouseLoaders</td><td>struct</td><td>Loaders for warehouse shards</td></tr>
<tr><td>split_runs</td><td>fn</td><td>Split runs into train/val</td></tr>
<tr><td>split_runs_stratified</td><td>fn</td><td>Stratified split of runs</td></tr>
<tr><td>count_boxes</td><td>fn</td><td>Count boxes in samples</td></tr>
<tr><td>validate_summary</td><td>fn</td><td>Validate summary against thresholds</td></tr>
<tr><td>summarize_with_thresholds</td><td>fn</td><td>Summarize with thresholds</td></tr>
<tr><td>summarize_root_with_thresholds</td><td>fn</td><td>Summarize root with thresholds</td></tr>
<tr><td>summarize_runs</td><td>fn</td><td>Summarize runs from indices</td></tr>
<tr><td>index_runs</td><td>fn</td><td>Index runs under a root</td></tr>
<tr><td>load_run_dataset</td><td>fn</td><td>Load dataset from a run dir</td></tr>
<tr><td>load_sample_for_etl</td><td>fn</td><td>Load a sample for ETL</td></tr>
<tr><td>build_train_val_iters</td><td>fn</td><td>Build train/val iterators</td></tr>
<tr><td>build_greedy_targets</td><td>fn</td><td>Build targets for training</td></tr>
</tbody>
</table>
</div>
<h2 id="links-91"><a class="header" href="#links-91">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge-burn-dataset</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-burn_dataset"><a class="header" href="#traits--generics-burn_dataset">Traits &amp; Generics (burn_dataset)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-9"><a class="header" href="#extensibility-traits-9">Extensibility traits</a></h2>
<ul>
<li><code>WarehouseShardStore</code> (feature <code>burn_runtime</code>): trait abstraction for providing shard iterators. Methods: <code>train_iter</code>, <code>val_iter</code>, <code>train_len</code>, <code>val_len</code>, <code>total_shards</code>, <code>mode</code>.</li>
</ul>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<ul>
<li><code>InMemoryStore</code>: stores shard buffers in memory; implements <code>WarehouseShardStore</code>.</li>
<li><code>StreamingStore</code>: mmap/streaming-backed shard access; implements <code>WarehouseShardStore</code>.</li>
<li><code>WarehouseLoaders</code> wraps a boxed <code>WarehouseShardStore</code>.</li>
</ul>
<h2 id="generics-and-bounds-9"><a class="header" href="#generics-and-bounds-9">Generics and bounds</a></h2>
<ul>
<li><code>BatchIter&lt;B: Backend&gt;</code> and <code>BurnBatch&lt;B&gt;</code> depend on Burn <code>Backend</code> for tensor creation.</li>
<li>Loader abstractions use concrete structs; trait object (<code>Box&lt;dyn WarehouseShardStore&gt;</code>) allows swapping store strategies.</li>
<li>Most APIs are concrete; no higher-rank or lifetime-heavy generics.</li>
</ul>
<h2 id="design-notes-9"><a class="header" href="#design-notes-9">Design notes</a></h2>
<ul>
<li>Trait object for <code>WarehouseShardStore</code> keeps CLI/runtime selection simple (stream vs memory).</li>
<li>Backend-generic batch iteration mirrors training/inference expectations; consumers must align <code>max_boxes</code>/<code>target_size</code> configs with models.</li>
<li>If additional store types are added (e.g., remote), implement <code>WarehouseShardStore</code> to plug in without changing callers.</li>
</ul>
<h2 id="links-92"><a class="header" href="#links-92">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="burn_dataset-module-map"><a class="header" href="#burn_dataset-module-map">burn_dataset: Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>lib.rs</code>: Single-module crate defining dataset types, transforms, summaries/validation, shard metadata/manifest, iterators, and helpers.
<ul>
<li>Types: DatasetConfig, SampleIndex, DatasetSample.</li>
<li>Iterators: BatchIter, WarehouseBatchIter.</li>
<li>Helpers: index/summarize/load/split/build iterators.</li>
</ul>
</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>pure Rust with Burn/backends.</li>
<li>consumed by training/tools.</li>
<li>no submodules beyond lib.rs.</li>
</ul>
<h2 id="links-93"><a class="header" href="#links-93">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="burn_dataset-lifecycle"><a class="header" href="#burn_dataset-lifecycle">burn_dataset: Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-9"><a class="header" href="#typical-usage-9">Typical usage</a></h2>
<ul>
<li>Index and load runs into samples:
<pre><code class="language-rust ignore">let indices = index_runs(root)?;
let samples = load_run_dataset(&amp;indices[0].run_dir)?;</code></pre>
</li>
<li>Split and build iterators:
<pre><code class="language-rust ignore">let (train, val) = split_runs(&amp;indices, 0.8)?;
let loaders = build_train_val_iters(&amp;train, &amp;val, &amp;cfg)?;</code></pre>
</li>
<li>Validate/summarize warehouse:
<pre><code class="language-rust ignore">let summary = summarize_runs(&amp;indices)?;
validate_summary(&amp;summary, &amp;thresholds)?;</code></pre>
</li>
</ul>
<h2 id="execution-flow-9"><a class="header" href="#execution-flow-9">Execution flow</a></h2>
<ul>
<li>Index runs → create SampleIndex list.</li>
<li>Summarize/validate with thresholds as needed.</li>
<li>Load samples for ETL or build train/val iterators to feed Burn training (requires <code>burn_runtime</code> feature).</li>
<li>Optionally use shard metadata/manifest helpers for warehouse storage/loading.</li>
</ul>
<h2 id="notes-8"><a class="header" href="#notes-8">Notes</a></h2>
<ul>
<li>Backends/features: iterators/tensors require <code>burn_runtime</code>; otherwise use indexing/summary helpers.</li>
</ul>
<h2 id="links-94"><a class="header" href="#links-94">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-burn_dataset"><a class="header" href="#error-model-burn_dataset">Error Model (burn_dataset)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-9"><a class="header" href="#errors-defined-9">Errors defined</a></h2>
<ul>
<li><code>BurnDatasetError</code> enum: <code>Io</code>, <code>Json</code>, <code>Validation</code>, <code>MissingImage</code>, <code>MissingImageFile</code>, <code>Image</code>, <code>Other(String)</code>.</li>
<li>Type alias <code>DatasetResult&lt;T&gt; = Result&lt;T, BurnDatasetError&gt;</code>.</li>
</ul>
<h2 id="patterns-9"><a class="header" href="#patterns-9">Patterns</a></h2>
<ul>
<li>IO/serde/image errors wrapped with path context.</li>
<li>Validation errors flag label inconsistencies (bbox ordering, missing fields) and are returned early.</li>
<li>Batch/shard loaders propagate errors; permissive mode allows skipping with logging (controlled via env).</li>
<li>Warehouse loaders may return <code>Other</code> for offset/shape issues; streaming/mmap errors bubble via <code>Io</code>.</li>
</ul>
<h2 id="recoverability-9"><a class="header" href="#recoverability-9">Recoverability</a></h2>
<ul>
<li>Many errors are recoverable by skipping samples when <code>permissive</code> env toggles are set (<code>BURN_DATASET_PERMISSIVE</code>, <code>BURN_DATASET_WARN_ONCE</code>).</li>
<li>Missing images / invalid labels abort the current sample; iterators continue when permissive.</li>
<li>Shape mismatches (varying image sizes) are fatal for a batch unless target_size enforces consistency.</li>
</ul>
<h2 id="ergonomics-9"><a class="header" href="#ergonomics-9">Ergonomics</a></h2>
<ul>
<li>Structured error with path context aids debugging.</li>
<li>Some paths log and continue (permissive) vs. fail-fast; callers should choose mode based on use case.</li>
<li>Mixing env-driven behavior can be surprising; document/override in callers for deterministic CI.</li>
</ul>
<h2 id="links-95"><a class="header" href="#links-95">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-burn_dataset"><a class="header" href="#ownership--concurrency-burn_dataset">Ownership &amp; Concurrency (burn_dataset)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-9"><a class="header" href="#ownership-model-9">Ownership model</a></h2>
<ul>
<li>Most data is owned per loader/iterator: <code>DatasetSample</code>, buffers inside <code>BatchIter</code>, shard buffers.</li>
<li>Shard data may be memory-mapped (<code>memmap2::Mmap</code>) or owned <code>Vec&lt;f32&gt;</code>; accessors copy into caller-owned buffers when iterating.</li>
<li><code>ShardBuffer</code> encapsulates backing storage; <code>WarehouseBatchIter</code> holds either direct order or streaming channel.</li>
</ul>
<h2 id="concurrency-9"><a class="header" href="#concurrency-9">Concurrency</a></h2>
<ul>
<li><code>BatchIter</code> uses Rayon <code>par_iter</code> to load samples in parallel; internal buffers are reused per batch (owned by the iterator, not shared externally).</li>
<li><code>StreamingStore</code> spawns a thread feeding a bounded channel (<code>crossbeam_channel</code>) for streaming shards.</li>
<li>No shared mutable state across threads beyond controlled buffers; channel boundaries provide synchronization.</li>
</ul>
<h2 id="borrowing-boundaries-9"><a class="header" href="#borrowing-boundaries-9">Borrowing boundaries</a></h2>
<ul>
<li>Iterators own buffers and return owned tensors; no references escape.</li>
<li>Mmap/streamed shard access copies data into caller-owned vectors before constructing tensors.</li>
</ul>
<h2 id="async-boundaries-9"><a class="header" href="#async-boundaries-9">Async boundaries</a></h2>
<ul>
<li>Uses threads/channels for streaming; otherwise synchronous. No async/await.</li>
</ul>
<h2 id="risks--notes-9"><a class="header" href="#risks--notes-9">Risks / notes</a></h2>
<ul>
<li>BatchIter buffers are reused; not <code>Send + Sync</code> safe to share the iterator across threads.</li>
<li>StreamingStore thread will stop on errors; callers should handle missing data if the channel closes prematurely.</li>
</ul>
<h2 id="links-96"><a class="header" href="#links-96">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-burn_dataset"><a class="header" href="#performance-notes-burn_dataset">Performance Notes (burn_dataset)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-9"><a class="header" href="#hot-paths-9">Hot paths</a></h2>
<ul>
<li>Image decode/augmentation in <code>load_sample</code> and <code>BatchIter</code>.</li>
<li>Rayon parallel load in <code>BatchIter::next_batch</code>.</li>
<li>Warehouse shard load (mmap/streaming) in <code>ShardBuffer::copy_sample</code> and <code>WarehouseBatchIter</code>.</li>
</ul>
<h2 id="allocation-patterns-9"><a class="header" href="#allocation-patterns-9">Allocation patterns</a></h2>
<ul>
<li>Buffers (<code>images_buf</code>, <code>boxes_buf</code>, <code>mask_buf</code>, <code>frame_ids_buf</code>) are reused per batch but can grow; preallocated to capacity when possible.</li>
<li>Shard loaders copy data from mmap/stream into owned vectors per batch.</li>
<li>Transform pipeline allocates intermediate images during jitter/resize.</li>
</ul>
<h2 id="trait-objects-9"><a class="header" href="#trait-objects-9">Trait objects</a></h2>
<ul>
<li><code>WarehouseShardStore</code> trait object allows different backends with minor vtable overhead; negligible compared to IO/compute.</li>
</ul>
<h2 id="assumptions-9"><a class="header" href="#assumptions-9">Assumptions</a></h2>
<ul>
<li>Images in a batch share dimensions; otherwise collation fails.</li>
<li>Parallelism is helpful for CPU-bound decode; IO/cache behavior may dominate on large datasets.</li>
<li>Env tuning for logging/permissive/trace impacts performance minimally.</li>
</ul>
<h2 id="improvements-8"><a class="header" href="#improvements-8">Improvements</a></h2>
<ul>
<li>Further buffer pooling or preallocation could reduce reallocs for large batches.</li>
<li>Consider SIMD-optimized aug if profiling shows jitter/blur as bottlenecks.</li>
<li>Tune Rayon thread pool or chunk sizes for specific workloads.</li>
</ul>
<h2 id="links-97"><a class="header" href="#links-97">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-burn_dataset"><a class="header" href="#examples-burn_dataset">Examples (burn_dataset)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-index-and-summarize-a-captures-root"><a class="header" href="#1-index-and-summarize-a-captures-root">1) Index and summarize a captures root</a></h2>
<pre><code class="language-rust ignore">use burn_dataset::{index_runs, summarize_with_thresholds, ValidationThresholds};
use std::path::Path;

fn main() -&gt; burn_dataset::DatasetResult&lt;()&gt; {
    let indices = index_runs(Path::new("assets/datasets/captures"))?;
    let report = summarize_with_thresholds(&amp;indices, &amp;ValidationThresholds::from_env())?;
    println!("summary outcome = {:?}", report.outcome);
    Ok(())
}</code></pre>
<h2 id="links-98"><a class="header" href="#links-98">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<h2 id="2-load-a-run-eagerly"><a class="header" href="#2-load-a-run-eagerly">2) Load a run eagerly</a></h2>
<pre><code class="language-rust ignore">use burn_dataset::load_run_dataset;
use std::path::Path;

fn main() -&gt; burn_dataset::DatasetResult&lt;()&gt; {
    let samples = load_run_dataset(Path::new("assets/datasets/captures/run_00001"))?;
    println!("loaded {} samples", samples.len());
    Ok(())
}</code></pre>
<h2 id="3-build-trainval-iterators-burn_runtime-feature"><a class="header" href="#3-build-trainval-iterators-burn_runtime-feature">3) Build train/val iterators (burn_runtime feature)</a></h2>
<pre><code class="language-rust ignore">fn main() -&gt; burn_dataset::DatasetResult&lt;()&gt; {
    #[cfg(feature = "burn_runtime")]
    {
        use burn_dataset::{build_train_val_iters, DatasetConfig, BatchIter};
        let train_cfg = DatasetConfig::default();
        let (mut train, mut val) = build_train_val_iters(
            std::path::Path::new("assets/datasets/captures"),
            0.2,
            train_cfg,
            None,
        )?;
        // Example: pull one batch on NdArray backend
        let device = &lt;burn_ndarray::NdArray&lt;f32&gt; as burn::tensor::backend::Backend&gt;::Device::default();
        if let Some(batch) = train.next_batch::&lt;burn_ndarray::NdArray&lt;f32&gt;&gt;(4, &amp;device)? {
            println!("batch boxes shape = {:?}", batch.boxes.dims());
        }
    }
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-burn_dataset"><a class="header" href="#design-review-burn_dataset">Design Review (burn_dataset)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-9"><a class="header" href="#whats-solid-9">What’s solid</a></h2>
<ul>
<li>Comprehensive dataset handling: validation, augmentation, splitting, batching, and sharded warehouse support.</li>
<li>Flexible store abstraction (<code>WarehouseShardStore</code>) with in-memory and streaming implementations.</li>
<li>Env-tunable behavior (logging, permissive mode, prefetch) without changing code.</li>
</ul>
<h2 id="risks--gaps-9"><a class="header" href="#risks--gaps-9">Risks / gaps</a></h2>
<ul>
<li>Permissive/error handling via env can hide data quality issues unless monitored.</li>
<li>Collation requires consistent image sizes; no automatic resize/pad path may surprise users with mixed data.</li>
<li>Augmentation and buffer reuse are hand-rolled; performance could vary across workloads.</li>
</ul>
<h2 id="refactor-ideas-9"><a class="header" href="#refactor-ideas-9">Refactor ideas</a></h2>
<ul>
<li>Add explicit configuration (struct) for permissive/logging/trace instead of env-only control, enabling code-driven behavior (and tests).</li>
<li>Provide an optional resize/padding strategy in collation to handle heterogeneous datasets gracefully.</li>
<li>Consider centralizing augmentation parameters and using SIMD/parallel image ops if profiling shows hotspots; add metrics hooks for skipped/errored samples.</li>
</ul>
<h2 id="links-99"><a class="header" href="#links-99">Links</a></h2>
<ul>
<li>Source: <code>crates/burn_dataset/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-tools-shared-overview"><a class="header" href="#cortenforge-tools-shared-overview">cortenforge-tools (shared): Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-10"><a class="header" href="#problem-statement-10">Problem statement</a></h2>
<p>Bundle tooling bins and helpers for capture/overlay/ETL/export and simple inference, shared across apps. Currently contains both shared and app-specific bins; plan to split app-facing pieces into app repos and keep only shared utilities here.</p>
<h2 id="scope-10"><a class="header" href="#scope-10">Scope</a></h2>
<ul>
<li>Bins: overlay_labels, prune_empty, warehouse_etl/export/cmd, single_infer (shared-ish); app-facing bins gated by features (datagen_scheduler, tui, gpu_macos_helper, datagen).</li>
<li>Shared helpers: CLI services and warehouse commands in <code>services</code> / <code>warehouse_commands</code> (only live here today).</li>
<li>Uses substrate crates: capture_utils, data_contracts, vision_core, inference/models, cli_support, burn_dataset.</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Tools read <code>cortenforge-tools.toml</code> from the repo root by default (or <code>CORTENFORGE_TOOLS_CONFIG</code> for a custom path). Use it to set binary names, paths, and command templates so tools work across app repos without hardcoded assumptions.</p>
<pre><code class="language-toml">sim_bin = "sim_view"
assets_root = "assets"
captures_root = "assets/datasets/captures"

[warehouse]
train_template = "cargo train_hp --model ${MODEL} --batch-size ${BATCH}"
</code></pre>
<p>Template placeholders:</p>
<ul>
<li><code>${MODEL}</code>, <code>${BATCH}</code>, <code>${LOG_EVERY}</code>, <code>${EXTRA_ARGS}</code></li>
<li><code>${MANIFEST}</code>, <code>${STORE}</code>, <code>${WGPU_BACKEND}</code>, <code>${WGPU_ADAPTER}</code></li>
</ul>
<p>Config precedence: CLI flags &gt; config file &gt; environment &gt; defaults.</p>
<h2 id="non-goals-10"><a class="header" href="#non-goals-10">Non-goals</a></h2>
<ul>
<li>No app-specific world/config baked into shared bins; app-facing bins should move to app repos.</li>
<li>No recorder/meta/world definitions; uses shared schemas/helpers.</li>
</ul>
<h2 id="who-should-use-it-10"><a class="header" href="#who-should-use-it-10">Who should use it</a></h2>
<ul>
<li>Consumers needing CLI tooling for captures/warehouse/inference without app-specific logic.</li>
<li>Contributors trimming/splitting the crate: move app-only bins out, fold shared helpers into existing crates (cli_support/capture_utils) and keep a thin bin crate.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-tools-shared-public-api"><a class="header" href="#cortenforge-tools-shared-public-api">cortenforge-tools (shared): Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>RunManifestSummary</td><td>struct</td><td>Summary info for a run</td></tr>
<tr><td>RunInfo</td><td>struct</td><td>Info about a run (path, metadata)</td></tr>
<tr><td>ServiceError</td><td>enum</td><td>Errors from service helpers</td></tr>
<tr><td>ServiceCommand</td><td>struct</td><td>Command wrapper for spawning services</td></tr>
<tr><td>DatagenOptions</td><td>struct</td><td>Options to build datagen command</td></tr>
<tr><td>TrainOptions</td><td>struct</td><td>Options to build train command</td></tr>
<tr><td>list_runs</td><td>fn</td><td>List runs under a root</td></tr>
<tr><td>spawn</td><td>fn</td><td>Spawn a service command</td></tr>
<tr><td>datagen_command</td><td>fn</td><td>Build datagen command</td></tr>
<tr><td>train_command</td><td>fn</td><td>Build train command</td></tr>
<tr><td>read_metrics</td><td>fn</td><td>Read metrics from a path</td></tr>
<tr><td>read_log_tail</td><td>fn</td><td>Tail logs from a path</td></tr>
<tr><td>is_process_running</td><td>fn</td><td>Check if a PID is running</td></tr>
<tr><td>read_status</td><td>fn</td><td>Read status JSON from a path</td></tr>
<tr><td>draw_rect / normalize_box</td><td>re-export</td><td>Overlay helpers from vision_core</td></tr>
<tr><td>generate_overlays / prune_run / JsonRecorder</td><td>re-export</td><td>Recorder helpers from capture_utils</td></tr>
<tr><td>WarehouseStore</td><td>enum</td><td>Warehouse store target (local/object store)</td></tr>
<tr><td>ModelKind</td><td>enum</td><td>Model selection for command builder</td></tr>
<tr><td>CmdConfig&lt;’a&gt;</td><td>struct</td><td>Config for warehouse command builder</td></tr>
<tr><td>DEFAULT_CONFIG</td><td>const</td><td>Default command config</td></tr>
<tr><td>Shell</td><td>enum</td><td>Shell target for command rendering</td></tr>
<tr><td>build_command</td><td>fn</td><td>Build warehouse command string</td></tr>
<tr><td>Modules (pub mod)</td><td>module</td><td>overlay, recorder, services, warehouse_commands (builder/common)</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-cortenforge-tools"><a class="header" href="#traits--generics-cortenforge-tools">Traits &amp; Generics (cortenforge-tools)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-10"><a class="header" href="#extensibility-traits-10">Extensibility traits</a></h2>
<ul>
<li>None defined; crate is thin wrappers/re-exports and concrete helpers.</li>
</ul>
<h2 id="generics-and-bounds-10"><a class="header" href="#generics-and-bounds-10">Generics and bounds</a></h2>
<ul>
<li>Concrete structs/helpers only; no generic parameters.</li>
<li><code>warehouse_commands</code> builders use plain enums (<code>WarehouseStore</code>, <code>ModelKind</code>) and string-building helpers—no trait bounds.</li>
<li>Services/overlay/recorder modules rely on external traits (<code>vision_core::Detector</code>, <code>capture_utils::Recorder</code>) but do not introduce new ones.</li>
</ul>
<h2 id="design-notes-10"><a class="header" href="#design-notes-10">Design notes</a></h2>
<ul>
<li>Intentional lack of traits keeps CLI/bin usage simple. Extensibility is expected via adding new modules/bins rather than generic abstractions.</li>
<li>As the crate is slated for split/retirement, avoid adding new trait surfaces here; shared functionality can move into other crates with clearer ownership.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-tools-shared-module-map"><a class="header" href="#cortenforge-tools-shared-module-map">cortenforge-tools (shared): Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>lib.rs</code>: Exposes modules and re-exports capture_utils.</li>
<li><code>overlay</code>: Re-exports overlay helpers from vision_core.</li>
<li><code>recorder</code>: Re-exports recorder helpers from capture_utils (JsonRecorder, generate_overlays, prune_run).</li>
<li><code>services</code>: Shared CLI/service helpers.
<ul>
<li>Types: RunManifestSummary, RunInfo, ServiceCommand, DatagenOptions, TrainOptions.</li>
<li>Functions: list_runs, spawn, datagen_command, train_command, read_metrics/logs/status.</li>
</ul>
</li>
<li><code>warehouse_commands</code>: Common/Builder submodules for warehouse command generation.
<ul>
<li>Types: WarehouseStore, ModelKind, CmdConfig, DEFAULT_CONFIG, Shell.</li>
<li>Functions: build_command.</li>
</ul>
</li>
<li><code>bin/</code>: Binaries (overlay_labels, prune_empty, warehouse_etl/export/cmd, single_infer).
<ul>
<li>App-gated bins: datagen, datagen_scheduler, tui, gpu_macos_helper.</li>
</ul>
</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>services/warehouse_commands use cli_support and substrate crates.</li>
<li>overlay/recorder wrap vision_core/capture_utils.</li>
<li>bins wire these helpers into CLIs.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-tools-shared-lifecycle"><a class="header" href="#cortenforge-tools-shared-lifecycle">cortenforge-tools (shared): Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-shared-bins"><a class="header" href="#typical-usage-shared-bins">Typical usage (shared bins)</a></h2>
<ul>
<li>Run overlay/prune:
<pre><code class="language-bash">cargo run -p cortenforge-tools --bin overlay_labels -- --run &lt;run_dir&gt;
cargo run -p cortenforge-tools --bin prune_empty -- --input &lt;run_dir&gt; --output &lt;out_root&gt;
</code></pre>
</li>
<li>ETL/export/cmd:
<pre><code class="language-bash">cargo run -p cortenforge-tools --bin warehouse_etl -- --run &lt;run_dir&gt; --out &lt;warehouse_root&gt;
cargo run -p cortenforge-tools --bin warehouse_cmd -- --manifest &lt;manifest&gt; --shell bash
cargo run -p cortenforge-tools --bin warehouse_export -- --warehouse &lt;warehouse_root&gt;
</code></pre>
</li>
<li>Single inference:
<pre><code class="language-bash">cargo run -p cortenforge-tools --bin single_infer -- --image &lt;path&gt; --weights &lt;checkpoint&gt;
</code></pre>
</li>
</ul>
<h2 id="execution-flow-shared-bins"><a class="header" href="#execution-flow-shared-bins">Execution flow (shared bins)</a></h2>
<ul>
<li>Parse CLI args using cli_support helpers.</li>
<li>Operate on capture/warehouse artifacts using capture_utils, data_contracts, burn_dataset, inference/models as needed.</li>
<li>App-facing bins (<code>datagen</code>, <code>datagen_scheduler</code>, <code>tui</code>, <code>gpu_macos_helper</code>) are gated by features; planned to move to app repo.</li>
</ul>
<h2 id="notes-9"><a class="header" href="#notes-9">Notes</a></h2>
<ul>
<li>Shared helpers (services/warehouse_commands) currently live here; plan to fold into cli_support/capture_utils and keep a thin bin crate or move app-specific bins out.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-cortenforge-tools"><a class="header" href="#error-model-cortenforge-tools">Error Model (cortenforge-tools)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-10"><a class="header" href="#errors-defined-10">Errors defined</a></h2>
<ul>
<li>No custom error types; relies on underlying crates:
<ul>
<li>Services: <code>Result&lt;_, ServiceError&gt;</code> (wraps <code>io</code> and <code>serde_json</code> errors).</li>
<li>Warehouse command builder: pure string building (no errors).</li>
<li>Overlay/recorder modules re-export fallible functions from <code>capture_utils</code> (io/anyhow).</li>
</ul>
</li>
</ul>
<h2 id="patterns-10"><a class="header" href="#patterns-10">Patterns</a></h2>
<ul>
<li>Listing runs/reading manifests: bubbles IO/JSON errors via <code>ServiceError</code>.
<ul>
<li>Some operations are best-effort (counting artifacts) and may ignore individual failures.</li>
</ul>
</li>
<li>Command builders are infallible.</li>
<li>Recorder/overlay use upstream error models (IO/anyhow).</li>
</ul>
<h2 id="recoverability-10"><a class="header" href="#recoverability-10">Recoverability</a></h2>
<ul>
<li>Service errors are caller-visible; bins should handle/log them and continue or exit.</li>
<li>Most tooling binaries prefer to continue when partial data is missing (e.g., missing manifest).</li>
</ul>
<h2 id="ergonomics-10"><a class="header" href="#ergonomics-10">Ergonomics</a></h2>
<ul>
<li><code>ServiceError</code> is typed (<code>thiserror</code>), improving display vs. bare <code>io::Error</code>.</li>
<li>Mixed best-effort behavior means some issues are silent; add logging in bins if stricter behavior is desired.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-cortenforge-tools"><a class="header" href="#ownership--concurrency-cortenforge-tools">Ownership &amp; Concurrency (cortenforge-tools)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-10"><a class="header" href="#ownership-model-10">Ownership model</a></h2>
<ul>
<li>Services operate on owned paths/commands; no shared state.</li>
<li>Overlay/recorder modules re-export functions that operate on owned buffers/paths.</li>
<li>Warehouse command builder constructs strings; stateless.</li>
<li>Some bins may share <code>ServiceCommand</code>/options, but the crate itself holds no global mutable data.</li>
</ul>
<h2 id="concurrency-10"><a class="header" href="#concurrency-10">Concurrency</a></h2>
<ul>
<li>Crate code is synchronous; concurrency is driven by calling binaries (e.g., spawning processes).</li>
<li><code>is_process_running</code>/<code>read_status</code> are read-only operations; no shared mutable state.</li>
</ul>
<h2 id="borrowing-boundaries-10"><a class="header" href="#borrowing-boundaries-10">Borrowing boundaries</a></h2>
<ul>
<li>All functions take owned/borrowed params for the duration of the call; no references are stored.</li>
</ul>
<h2 id="async-boundaries-10"><a class="header" href="#async-boundaries-10">Async boundaries</a></h2>
<ul>
<li>None; any async/process orchestration is managed by callers/binaries.</li>
</ul>
<h2 id="risks--notes-10"><a class="header" href="#risks--notes-10">Risks / notes</a></h2>
<ul>
<li>Concurrent invocations that touch the same run directories/logs should be coordinated by the caller; this crate does not guard against races.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-cortenforge-tools"><a class="header" href="#performance-notes-cortenforge-tools">Performance Notes (cortenforge-tools)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-10"><a class="header" href="#hot-paths-10">Hot paths</a></h2>
<ul>
<li>None in the helpers themselves; performance is dictated by underlying tools (capture_utils, warehouse/training binaries).</li>
</ul>
<h2 id="allocation-patterns-10"><a class="header" href="#allocation-patterns-10">Allocation patterns</a></h2>
<ul>
<li>Services allocate small vectors/strings for command assembly; minimal.</li>
<li>Warehouse command builder constructs strings; negligible.</li>
<li>Overlay/recorder functions reuse upstream implementations (overlay/prune/recorder) with their own allocation patterns.</li>
</ul>
<h2 id="trait-objects-10"><a class="header" href="#trait-objects-10">Trait objects</a></h2>
<ul>
<li>Uses upstream trait objects (recorders/detectors) when re-exported; overhead is negligible relative to IO/compute of the underlying crates.</li>
</ul>
<h2 id="assumptions-10"><a class="header" href="#assumptions-10">Assumptions</a></h2>
<ul>
<li>This crate is not performance-critical; primarily orchestration/wrapper code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-cortenforge-tools"><a class="header" href="#examples-cortenforge-tools">Examples (cortenforge-tools)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-list-runs-and-print-summary"><a class="header" href="#1-list-runs-and-print-summary">1) List runs and print summary</a></h2>
<pre><code class="language-rust ignore">use cortenforge_tools::services;
use std::path::Path;

fn main() -&gt; Result&lt;(), services::ServiceError&gt; {
    let runs = services::list_runs(Path::new("assets/datasets/captures"))?;
    for run in runs {
        println!(
            "{:?} labels={} images={} overlays={}",
            run.path, run.label_count, run.image_count, run.overlay_count
        );
    }
    Ok(())
}</code></pre>
<h2 id="2-build-a-datagen-command"><a class="header" href="#2-build-a-datagen-command">2) Build a datagen command</a></h2>
<pre><code class="language-rust ignore">use cortenforge_tools::services::{datagen_command, DatagenOptions};
use std::path::PathBuf;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let cmd = datagen_command(&amp;DatagenOptions {
        output_root: PathBuf::from("assets/datasets/captures"),
        seed: Some(1234),
        max_frames: Some(100),
        headless: true,
        prune_empty: true,
        prune_output_root: None,
    })?;
    println!("{:?} {:?}", cmd.program, cmd.args);
    Ok(())
}</code></pre>
<h2 id="3-build-a-warehouse-command-line"><a class="header" href="#3-build-a-warehouse-command-line">3) Build a warehouse command line</a></h2>
<pre><code class="language-rust ignore">use cortenforge_tools::warehouse_commands::{builder, common};

fn main() {
    let cfg = common::DEFAULT_CONFIG
        .with_manifest("artifacts/tensor_warehouse/v1/manifest.json")
        .with_batch_size(16)
        .with_model(common::ModelKind::Tiny);
    let bash_cmd = builder::build_command(&amp;cfg, builder::Shell::Bash);
    println!("bash: {}", bash_cmd);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-cortenforge-tools"><a class="header" href="#design-review-cortenforge-tools">Design Review (cortenforge-tools)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-10"><a class="header" href="#whats-solid-10">What’s solid</a></h2>
<ul>
<li>Thin orchestration/wrapper layer; leverages other crates rather than duplicating logic.</li>
<li>Helpful service helpers and warehouse command builders reduce boilerplate in bins.</li>
<li>Feature flags gate heavier bins/features to keep default footprint small.</li>
</ul>
<h2 id="risks--gaps-10"><a class="header" href="#risks--gaps-10">Risks / gaps</a></h2>
<ul>
<li>Mix of shared and app-specific tooling; unclear boundary increases risk of leaking app concerns into the library repo.</li>
<li>Error handling is best-effort; some silent skips (e.g., missing manifests) could hide issues.</li>
<li>No clear publishing story; keeping <code>publish = false</code> is intentional but needs ongoing discipline.</li>
</ul>
<h2 id="refactor-ideas-10"><a class="header" href="#refactor-ideas-10">Refactor ideas</a></h2>
<ul>
<li>Execute the split/trim plan: move app-specific bins to the app repo, keep only shared helpers here.</li>
<li>Add clearer logging/metrics for service operations to surface failures.</li>
<li>Document and enforce ownership boundaries (what stays here vs. moves) to avoid future drift.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-umbrella-overview"><a class="header" href="#cortenforge-umbrella-overview">cortenforge (umbrella): Overview</a></h1>
<p>Quick read: What this crate does and where it fits.</p>
<h2 id="problem-statement-11"><a class="header" href="#problem-statement-11">Problem statement</a></h2>
<p>Provide a facade/umbrella crate that re-exports the CortenForge stack with feature wiring to make it easy for consumers to opt into runtime, vision, training, inference, and tooling components via a single dependency.</p>
<h2 id="scope-11"><a class="header" href="#scope-11">Scope</a></h2>
<ul>
<li>Re-export member crates (sim_core, vision_core/runtime, data_contracts, capture_utils, models, training, inference, burn_dataset, cli_support) with feature mapping.</li>
<li>Feature wiring for common stacks (burn-runtime/burn-wgpu, model variants, runtime/vision toggles).</li>
</ul>
<h2 id="non-goals-11"><a class="header" href="#non-goals-11">Non-goals</a></h2>
<ul>
<li>No own implementations; purely a facade.</li>
<li>No app-specific defaults; consumers still select features explicitly.</li>
</ul>
<h2 id="who-should-use-it-11"><a class="header" href="#who-should-use-it-11">Who should use it</a></h2>
<ul>
<li>Downstream consumers wanting a single entry point to the substrate with feature toggles rather than pinning each crate individually.</li>
<li>Contributors maintaining feature mappings and keeping versions aligned across the stack.</li>
</ul>
<h2 id="links-100"><a class="header" href="#links-100">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-umbrella-public-api"><a class="header" href="#cortenforge-umbrella-public-api">cortenforge (umbrella): Public API</a></h1>
<p>Quick read: The public surface; use docs.rs for exact signatures.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>sim_core</td><td>re-export</td><td>Runtime scaffolding crate</td></tr>
<tr><td>vision_core</td><td>re-export</td><td>Vision interfaces/overlay math</td></tr>
<tr><td>vision_runtime</td><td>re-export</td><td>Capture/inference plugins</td></tr>
<tr><td>data_contracts</td><td>re-export</td><td>Schemas/validation</td></tr>
<tr><td>capture_utils</td><td>re-export</td><td>Recorder sinks/helpers</td></tr>
<tr><td>models</td><td>re-export</td><td>Model definitions (TinyDet/BigDet)</td></tr>
<tr><td>inference</td><td>re-export</td><td>Detector factory</td></tr>
<tr><td>training</td><td>re-export</td><td>Training/eval pipeline</td></tr>
<tr><td>burn_dataset</td><td>re-export</td><td>Burn dataset loader</td></tr>
<tr><td>cli_support</td><td>re-export</td><td>Shared CLI helpers</td></tr>
</tbody>
</table>
</div>
<h2 id="links-101"><a class="header" href="#links-101">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
<li>Docs.rs: https://docs.rs/cortenforge</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--generics-cortenforge"><a class="header" href="#traits--generics-cortenforge">Traits &amp; Generics (cortenforge)</a></h1>
<p>Quick read: Extension points and the constraints they impose.</p>
<h2 id="extensibility-traits-11"><a class="header" href="#extensibility-traits-11">Extensibility traits</a></h2>
<ul>
<li>None; this crate only re-exports others behind feature flags.</li>
</ul>
<h2 id="generics-and-bounds-11"><a class="header" href="#generics-and-bounds-11">Generics and bounds</a></h2>
<ul>
<li>No generics; all items are <code>pub use</code> of other crates gated by features (<code>sim-core</code>, <code>vision-core</code>, etc.).</li>
</ul>
<h2 id="design-notes-11"><a class="header" href="#design-notes-11">Design notes</a></h2>
<ul>
<li>Keep feature names aligned with member crate names; adding/removing crates requires updating the feature list and re-exports.</li>
<li>This crate intentionally exposes no additional APIs or traits; consumers should depend on member crates directly if they need fine-grained control.</li>
</ul>
<h2 id="links-102"><a class="header" href="#links-102">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-umbrella-module-map"><a class="header" href="#cortenforge-umbrella-module-map">cortenforge (umbrella): Module Map</a></h1>
<p>Quick read: What each module owns and why it exists.</p>
<ul>
<li><code>lib.rs</code>: Single-module facade; re-exports member crates: sim_core, vision_core, vision_runtime, data_contracts, capture_utils, models, inference, training, burn_dataset, cli_support.</li>
<li>No additional submodules; feature wiring aligns with member crates.</li>
</ul>
<p>Cross-module dependencies:</p>
<ul>
<li>none internally.</li>
<li>this crate is purely a facade delegating to underlying crates.</li>
</ul>
<h2 id="links-103"><a class="header" href="#links-103">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cortenforge-umbrella-lifecycle"><a class="header" href="#cortenforge-umbrella-lifecycle">cortenforge (umbrella): Lifecycle</a></h1>
<p>Quick read: How data flows through this crate in practice.</p>
<h2 id="typical-usage-10"><a class="header" href="#typical-usage-10">Typical usage</a></h2>
<ul>
<li>Add dependency and select features instead of pinning individual crates:
<pre><code class="language-toml">[dependencies]
cortenforge = { version = "0.1.1", features = ["sim-core", "vision-core", "vision-runtime", "training", "inference", "models", "capture-utils"] }
</code></pre>
</li>
<li>Import from prelude or modules as needed; underlying crates are re-exported.</li>
</ul>
<h2 id="execution-flow-10"><a class="header" href="#execution-flow-10">Execution flow</a></h2>
<ul>
<li>Consumer opts into feature sets (e.g., <code>sim-core</code>, <code>vision-runtime</code>, <code>training</code>, <code>inference</code>, <code>models</code>).</li>
<li>The umbrella exposes the member crates; lifecycle is managed by those crates. This crate is a facade only.</li>
</ul>
<h2 id="notes-10"><a class="header" href="#notes-10">Notes</a></h2>
<ul>
<li>Keep features aligned with member crates; burn-core 0.14.1 fixes the prior publish break.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-model-cortenforge"><a class="header" href="#error-model-cortenforge">Error Model (cortenforge)</a></h1>
<p>Quick read: How errors are surfaced and handled.</p>
<h2 id="errors-defined-11"><a class="header" href="#errors-defined-11">Errors defined</a></h2>
<ul>
<li>None; crate only re-exports other crates behind features.</li>
</ul>
<h2 id="patterns-11"><a class="header" href="#patterns-11">Patterns</a></h2>
<ul>
<li>Error behavior is inherited from the underlying crates; this crate does not wrap or alter errors.</li>
</ul>
<h2 id="recoverability--ergonomics"><a class="header" href="#recoverability--ergonomics">Recoverability / Ergonomics</a></h2>
<ul>
<li>Consumers should consult member crates’ error models. Using this facade does not change error surfaces.</li>
</ul>
<h2 id="links-104"><a class="header" href="#links-104">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ownership--concurrency-cortenforge"><a class="header" href="#ownership--concurrency-cortenforge">Ownership &amp; Concurrency (cortenforge)</a></h1>
<p>Quick read: Ownership, threading, and async expectations.</p>
<h2 id="ownership-model-11"><a class="header" href="#ownership-model-11">Ownership model</a></h2>
<ul>
<li>Pure facade; re-exports member crates. No owned state.</li>
</ul>
<h2 id="concurrency-11"><a class="header" href="#concurrency-11">Concurrency</a></h2>
<ul>
<li>Inherits behavior from re-exported crates; this crate introduces no threading or sharing concerns.</li>
</ul>
<h2 id="borrowing-boundaries--async"><a class="header" href="#borrowing-boundaries--async">Borrowing boundaries / Async</a></h2>
<ul>
<li>None; no APIs beyond re-exports.</li>
</ul>
<h2 id="risks--notes-11"><a class="header" href="#risks--notes-11">Risks / notes</a></h2>
<ul>
<li>Users should consult member crates for concurrency details. Facade use does not change ownership semantics.</li>
</ul>
<h2 id="links-105"><a class="header" href="#links-105">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-notes-cortenforge"><a class="header" href="#performance-notes-cortenforge">Performance Notes (cortenforge)</a></h1>
<p>Quick read: Hot paths, tradeoffs, and perf boundaries.</p>
<h2 id="hot-paths-11"><a class="header" href="#hot-paths-11">Hot paths</a></h2>
<ul>
<li>None; facade crate only re-exports members.</li>
</ul>
<h2 id="allocation-patterns-11"><a class="header" href="#allocation-patterns-11">Allocation patterns</a></h2>
<ul>
<li>None beyond what member crates perform.</li>
</ul>
<h2 id="trait-objects-11"><a class="header" href="#trait-objects-11">Trait objects</a></h2>
<ul>
<li>None added; uses member crates’ APIs directly.</li>
</ul>
<h2 id="assumptions-11"><a class="header" href="#assumptions-11">Assumptions</a></h2>
<ul>
<li>No performance impact; use member crates directly for fine-grained control.</li>
</ul>
<h2 id="links-106"><a class="header" href="#links-106">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples-cortenforge"><a class="header" href="#examples-cortenforge">Examples (cortenforge)</a></h1>
<p>Quick read: Minimal examples you can adapt safely.</p>
<h2 id="1-use-facade-to-pull-in-sim_core--vision_runtime"><a class="header" href="#1-use-facade-to-pull-in-sim_core--vision_runtime">1) Use facade to pull in sim_core + vision_runtime</a></h2>
<pre><code class="language-rust ignore">use cortenforge::{sim_core, vision_runtime};

fn main() {
    // Build a Bevy app using re-exported crates
    let mut app = bevy::prelude::App::new();
    app.add_plugins((vision_runtime::CapturePlugin, vision_runtime::InferencePlugin));
    // sim_core types are available through the facade
    app.insert_resource(sim_core::recorder_meta::RecorderWorldState::default());
}</code></pre>
<h2 id="2-compile-with-selected-features"><a class="header" href="#2-compile-with-selected-features">2) Compile with selected features</a></h2>
<pre><code class="language-toml">[dependencies]
cortenforge = { version = "0.1.1", features = ["sim-core", "vision-core", "vision-runtime", "data-contracts"] }
</code></pre>
<pre><code class="language-rust ignore">// Now you can reference re-exported crates without separate deps.
use cortenforge::vision_core::interfaces::Frame;</code></pre>
<h2 id="links-107"><a class="header" href="#links-107">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-cortenforge"><a class="header" href="#design-review-cortenforge">Design Review (cortenforge)</a></h1>
<p>Quick read: Strengths, risks, and refactor ideas.</p>
<h2 id="whats-solid-11"><a class="header" href="#whats-solid-11">What’s solid</a></h2>
<ul>
<li>Minimal facade; reduces dependency boilerplate for consumers who want a single entry point.</li>
<li>Feature-gated re-exports prevent pulling in unneeded crates.</li>
</ul>
<h2 id="risks--gaps-11"><a class="header" href="#risks--gaps-11">Risks / gaps</a></h2>
<ul>
<li>Facade can hide fine-grained versioning; consumers may prefer direct deps for clarity.</li>
<li>Needs maintenance when member crates change; easy to drift if not kept in sync.</li>
</ul>
<h2 id="refactor-ideas-11"><a class="header" href="#refactor-ideas-11">Refactor ideas</a></h2>
<ul>
<li>Keep facade optional in docs; encourage direct crate deps for advanced users.</li>
<li>Add a CI check to ensure feature list matches workspace members.</li>
</ul>
<h2 id="links-108"><a class="header" href="#links-108">Links</a></h2>
<ul>
<li>Source: <code>crates/cortenforge/src/lib.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>Use this chapter when you need policies, standards, or maintenance details. It is intentionally out of the main learning path.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="workspace-metadata"><a class="header" href="#workspace-metadata">Workspace Metadata</a></h1>
<p><strong>Why</strong>: A quick snapshot of workspace-wide config and publish posture.
<strong>How it fits</strong>: Useful when changing dependencies or release settings.
<strong>Learn more</strong>: See <a href="#reproducibility">Reproducibility</a>.</p>
<h2 id="workspace-metadata-root-cargotoml"><a class="header" href="#workspace-metadata-root-cargotoml">Workspace metadata (root <a href="https://github.com/via-balaena/CortenForge/blob/main/Cargo.toml">Cargo.toml</a>)</a></h2>
<p>Quick reference for workspace-wide configuration and publish posture.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td>resolver</td><td><code>2</code></td></tr>
<tr><td>Patch overrides</td><td>
<ul>
<li>local paths for all cortenforge crates (workspace dev convenience).</li>
</ul>
</td></tr>
<tr><td>Publish status</td><td>
<ul>
<li>most crates publishable</li>
<li><code>cortenforge-tools</code> marked <code>publish = false</code>.</li>
</ul>
</td></tr>
</tbody>
</table>
</div>
<h2 id="notes-11"><a class="header" href="#notes-11">Notes</a></h2>
<ul>
<li>
<p>resolver = 2</p>
<ul>
<li>opts into Cargo’s 2021+ feature resolver,
<ul>
<li>
<p>which prevents unwanted feature unification across the workspace.</p>
<ul>
<li>Under the old resolver, if one crate enabled a feature on a shared dependency, every other crate using that dependency inherited it automatically. That often resulted in unexpected behavior, larger binaries, and optional dependencies being pulled in without intent. With resolver 2, each crate resolves features independently, so only the features a crate explicitly opts into are activated.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Burn-core is fixed in 0.14.1; no vendored patch is required.</p>
</li>
<li>
<p><code>cortenforge-tools</code> stays unpublished because it includes app-specific bins; plan is to split shared helpers from app-facing pieces.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build--run"><a class="header" href="#build--run">Build &amp; Run</a></h1>
<p><strong>Why</strong>: A small, reliable set of commands you can trust.
<strong>How it fits</strong>: Use this before PRs and when sanity-checking changes.
<strong>Learn more</strong>: See <a href="#dev-loop">Dev Loop</a> and <a href="#reproducibility">Reproducibility</a>.</p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>Quick reference for common build and verification tasks.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Task</th><th>Command</th></tr>
</thead>
<tbody>
<tr><td>Format</td><td><code>cargo fmt --all</code></td></tr>
<tr><td>Lint</td><td><code>cargo clippy --workspace --all-targets --all-features -D warnings</code></td></tr>
<tr><td>Check</td><td><code>cargo check --workspace</code></td></tr>
<tr><td>Test</td><td><code>cargo test --workspace --locked</code></td></tr>
<tr><td>Docs</td><td><code>cargo doc --workspace --no-deps</code></td></tr>
<tr><td>mdBook</td><td><code>mdbook build docs/cortenforge_book</code></td></tr>
</tbody>
</table>
</div>
<h2 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature flags</a></h2>
<p>Default behavior and opt-in switches for common workflows.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Topic</th><th>Default</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Backends</td><td>NdArray</td><td>GPU/WGPU opt‑in via <code>backend-wgpu</code> (training/inference/models); <code>gpu_nvidia</code> on tools.</td></tr>
<tr><td>Model variants</td><td><code>tinydet</code></td><td><code>bigdet</code> optional.</td></tr>
<tr><td>Tools</td><td>none</td><td><code>tui</code>, <code>scheduler</code>, <code>gpu_nvidia</code> gate app‑specific bins.</td></tr>
</tbody>
</table>
</div>
<h2 id="common-flags"><a class="header" href="#common-flags">Common flags</a></h2>
<p>Flags that change dependency resolution or feature surfaces.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>--locked</code></td><td>Enforce lockfile resolution (useful before publish).</td></tr>
<tr><td><code>--all-features</code></td><td>Full surface area (opt-in GPU/tooling paths).</td></tr>
<tr><td><code>--features &lt;list&gt;</code></td><td>Target specific stacks (e.g., <code>backend-wgpu</code>, <code>tui</code>).</td></tr>
</tbody>
</table>
</div>
<h2 id="troubleshooting-skeleton"><a class="header" href="#troubleshooting-skeleton">Troubleshooting (skeleton)</a></h2>
<p>Common failure modes and the fastest fix.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Issue</th><th>Guidance</th></tr>
</thead>
<tbody>
<tr><td>Build fails due to burn-core/bincode</td><td>Ensure burn-core is 0.14.1+ and refresh the lockfile; publish may fail without a lockfile.</td></tr>
<tr><td>GPU/WGPU issues</td><td>Enable the right feature flags; skip on non-GPU hosts; check driver availability.</td></tr>
<tr><td>Tooling bins</td><td>Ensure required features (<code>tui</code>, <code>scheduler</code>, <code>gpu_nvidia</code>) are enabled; keep inputs minimal for smokes.</td></tr>
<tr><td>Docs build</td><td>Install mdBook; run <code>mdbook test</code> for doctests; mark non-runnable snippets with <code>ignore</code>.</td></tr>
<tr><td>Mermaid diagrams</td><td>Install <code>mdbook-mermaid</code> (<code>cargo install mdbook-mermaid</code>) before building this book.</td></tr>
<tr><td>Dependency policy</td><td>Shared deps should use root <code>[workspace.dependencies]</code>, but <code>bevy</code> stays per-crate until feature/default-features are unified.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dev-loop"><a class="header" href="#dev-loop">Dev Loop</a></h1>
<p><strong>Why</strong>: Keep feedback fast while you iterate.
<strong>How it fits</strong>: Pair these watchers with the main build commands.
<strong>Learn more</strong>: See <a href="#build--run">Build &amp; Run</a>.</p>
<h2 id="watchers"><a class="header" href="#watchers">Watchers</a></h2>
<p>Quick commands to keep code and docs continuously rebuilt.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Command</th></tr>
</thead>
<tbody>
<tr><td>Code</td><td><code>cargo watch -x fmt -x 'clippy --workspace --all-targets -D warnings' -x 'test --workspace'</code></td></tr>
<tr><td>Docs</td><td><code>cargo watch -w docs/cortenforge_book -s 'mdbook build docs/cortenforge_book'</code></td></tr>
</tbody>
</table>
</div>
<h2 id="doc-rebuild-strategy"><a class="header" href="#doc-rebuild-strategy">Doc rebuild strategy</a></h2>
<p>How to keep docs builds consistent and fast while iterating.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Topic</th><th>Guidance</th></tr>
</thead>
<tbody>
<tr><td>Makefile targets</td><td><code>make docs</code> (build), <code>make docs-watch</code> (serve/rebuild), <code>make docs-test</code> (doctests).</td></tr>
<tr><td>Snippet hygiene</td><td>Mark non-runnable snippets with <code>ignore</code>/<code>no_run</code> to keep <code>mdbook test</code> green.</td></tr>
</tbody>
</table>
</div>
<h2 id="keeping-mdbook-in-sync"><a class="header" href="#keeping-mdbook-in-sync">Keeping mdBook in sync</a></h2>
<p>Key checkpoints to keep documentation aligned with code changes.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trigger</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>APIs change</td><td>Update crate pages (overview/API/examples) and dependency graph if edges shift.</td></tr>
<tr><td>Features change</td><td>Update <code>feature_flags.md</code> and per-crate examples/snippets.</td></tr>
<tr><td>Releases</td><td>Refresh version strings, confirm burn-core note (0.14.1, no patch), and changelog.</td></tr>
<tr><td>Before merge</td><td>Run <code>mdbook test</code> and <code>mdbook build</code>.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reproducibility"><a class="header" href="#reproducibility">Reproducibility</a></h1>
<p><strong>Why</strong>: Ensure builds and releases are consistent across machines.
<strong>How it fits</strong>: Locks versions and documents expectations for stable outputs.
<strong>Learn more</strong>: See <a href="#build--run">Build &amp; Run</a>.</p>
<h2 id="lockfile-policy"><a class="header" href="#lockfile-policy">Lockfile policy</a></h2>
<p>How we keep local builds and publishes deterministic.</p>
<ul>
<li>Use the workspace <code>Cargo.lock</code> for local builds/tests; enforce with <code>--locked</code> before publish.
<ul>
<li>Note: published crates resolve without a lockfile; burn-core 0.14.1 fixes the prior bincode break.</li>
</ul>
</li>
</ul>
<h2 id="msrv"><a class="header" href="#msrv">MSRV</a></h2>
<p>Minimum Rust version and how to keep it consistent.</p>
<ul>
<li>Target Rust 1.75+ across crates (umbrella uses 2024 edition).
<ul>
<li>Keep MSRV aligned in docs/metadata; bump intentionally.</li>
</ul>
</li>
</ul>
<h2 id="ci-expectations"><a class="header" href="#ci-expectations">CI expectations</a></h2>
<p>Baseline checks to keep CI and local runs aligned.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Check</th><th>Command</th></tr>
</thead>
<tbody>
<tr><td>fmt</td><td><code>cargo fmt -- --check</code></td></tr>
<tr><td>clippy</td><td><code>cargo clippy --workspace --all-targets --all-features -D warnings</code></td></tr>
<tr><td>tests</td><td><code>cargo test --workspace --locked</code></td></tr>
<tr><td>optional</td><td><code>cargo deny check</code>, <code>cargo hakari generate &amp;&amp; cargo hakari manage-deps</code></td></tr>
<tr><td>docs</td><td><code>mdbook build docs/cortenforge_book</code>; <code>mdbook test</code> for doctests.</td></tr>
</tbody>
</table>
</div>
<h2 id="deterministic-builds"><a class="header" href="#deterministic-builds">Deterministic builds</a></h2>
<p>Habits that keep builds repeatable across machines.</p>
<ol>
<li>Use <code>--locked</code> to pin deps; avoid adding <code>path</code> patches except for local dev needs.</li>
<li>Document feature sets used in builds (NdArray default; GPU/WGPU opt-in).</li>
<li>Avoid network fetches in tests; keep fixtures small and included.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><strong>Why</strong>: Translate shared terms without hunting across pages.
<strong>How it fits</strong>: Use this when a term feels unfamiliar or overloaded.
<strong>Learn more</strong>: Start with <a href="#workspace-overview">Workspace Overview</a>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Term</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>CortenForge</td><td>Substrate of shared crates (sim/capture/vision/training/inference/tools).</td></tr>
<tr><td>App repo</td><td>Domain apps (e.g., colon_sim) that consume this substrate.</td></tr>
<tr><td>SimRunMode / ModeSet</td><td>Runtime mode gating (Common/SimDatagen/Inference).</td></tr>
<tr><td>Recorder</td><td>Capture pipeline (meta + world state + sinks). Defaults to JSON sink in capture_utils.</td></tr>
<tr><td>Warehouse</td><td>Tensor artifacts produced by ETL (<code>warehouse_etl</code>), consumed by training.</td></tr>
<tr><td>TinyDet / BigDet</td><td>Model variants defined in <code>models</code>.</td></tr>
<tr><td>Burn patch</td><td>Previous workaround for <code>burn-core 0.14.0</code>; fixed in <code>burn-core 0.14.1</code> (no patch required).</td></tr>
<tr><td>NdArray / WGPU</td><td>Default CPU backend vs optional GPU backend gated by features.</td></tr>
<tr><td>cortenforge-tools</td><td>Tooling package (crate <code>cortenforge_tools</code>); planned split of app-specific vs shared utilities.</td></tr>
<tr><td>CLI support</td><td>Shared argument parsing/helpers in <code>cli_support</code>.</td></tr>
<tr><td>ETL</td><td>Transforming captures to warehouse shards/manifests.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="book-style-guide"><a class="header" href="#book-style-guide">Book Style Guide</a></h1>
<p><strong>Why</strong>: Keep the book consistent and easy to skim.
<strong>How it fits</strong>: Use this before adding or refactoring pages.
<strong>Learn more</strong>: See <a href="#linking-style">Linking Style</a> and <a href="#docsrs-alignment">docs.rs Alignment</a>.</p>
<h2 id="chapters--structure"><a class="header" href="#chapters--structure">Chapters &amp; structure</a></h2>
<p>How the book is organized and what belongs where.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Area</th><th>Scope</th></tr>
</thead>
<tbody>
<tr><td>Top-level</td><td>workspace overview, feature flags, build/dev workflow.</td></tr>
<tr><td>Per-crate</td><td><code>10_crates/&lt;crate&gt;</code>: overview, public API, lifecycle/data flow, module map, error model, performance notes, examples, design review.</td></tr>
<tr><td>Cross-crate</td><td>canonical flows, integration contracts, docs.rs alignment, linking style, quality gates, changelog, reader’s guide.</td></tr>
</tbody>
</table>
</div>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming conventions</a></h2>
<p>Consistent naming and placement rules for new pages.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Convention</th><th>Guidance</th></tr>
</thead>
<tbody>
<tr><td>Paths</td><td><code>10_crates/&lt;crate&gt;/0X_*.md</code> for crate pages; <code>00_workspace/*.md</code> for workspace-wide topics.</td></tr>
<tr><td>Headings</td><td>Title Case; keep consistent order per crate.</td></tr>
<tr><td>Templates</td><td>reuse <code>_templates/crate_template.md</code> when creating new crate pages.</td></tr>
</tbody>
</table>
</div>
<h2 id="cross-link-style"><a class="header" href="#cross-link-style">Cross-link style</a></h2>
<p>Linking rules to keep references stable and readable.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Relative links</td><td><code>../&lt;crate&gt;/01_overview.md</code> for intra-book references.</td></tr>
<tr><td>Source links</td><td><code>crate/path.rs:L123</code> format when pointing to GitHub code.</td></tr>
<tr><td>Cross-references</td><td>Mention related crates/flows inline; avoid duplicate content by linking to existing sections.</td></tr>
</tbody>
</table>
</div>
<h2 id="auto-generated-vs-manual"><a class="header" href="#auto-generated-vs-manual">Auto-generated vs manual</a></h2>
<p>Which sections are machine-derived versus hand-curated.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Items</th></tr>
</thead>
<tbody>
<tr><td>Auto-generated</td><td>feature flags list, pub API tables, module maps, canonical flow diagrams.</td></tr>
<tr><td>Manual curation</td><td>lifecycle narratives, design reviews, performance notes, examples, error model nuances, integration contracts.</td></tr>
</tbody>
</table>
</div>
<h2 id="examples--code-blocks"><a class="header" href="#examples--code-blocks">Examples &amp; code blocks</a></h2>
<p>Rules for concise, copyable examples.</p>
<ol>
<li>Prefer small, focused snippets; mark non-runnable blocks with <code>ignore</code>/<code>no_run</code>.</li>
<li>Include inputs/outputs when helpful; tie examples to public API.</li>
</ol>
<h2 id="diagrams"><a class="header" href="#diagrams">Diagrams</a></h2>
<p>When and how to use Mermaid.</p>
<ul>
<li>Use Mermaid for dependency graphs and flows; place inline in relevant pages.
<ul>
<li>Keep diagrams minimal and update when APIs/flows change.</li>
</ul>
</li>
</ul>
<h2 id="quality"><a class="header" href="#quality">Quality</a></h2>
<p>Baseline expectations for every page.</p>
<ol>
<li>Each page should answer: what is this, how to use/extend it, boundaries, failure modes.</li>
<li>Keep prose concise; favor tables/diagrams over long text.</li>
<li>Note NdArray default and feature-gated GPU paths where relevant.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="linking-style"><a class="header" href="#linking-style">Linking Style</a></h1>
<p><strong>Why</strong>: Stable links make the book trustworthy over time.
<strong>How it fits</strong>: Use these rules whenever you reference code or docs.
<strong>Learn more</strong>: See <a href="#docsrs-alignment">docs.rs Alignment</a>.</p>
<p>Standardize source links to keep references consistent and stable.</p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>How to format links so they stay stable and readable.</p>
<ul>
<li>Use repo-relative paths with line anchors: <code>crate/path/to/file.rs:L123</code>.</li>
<li>Examples:
<ul>
<li><code>sim_core/src/hooks.rs:L10</code></li>
<li><code>vision_runtime/src/lib.rs:L75</code></li>
<li><code>docs/cortenforge_book/src/00_workspace/overview.md:L1</code> (for book refs)</li>
</ul>
</li>
<li>Avoid range anchors; link to the first relevant line.</li>
</ul>
<h2 id="when-to-link"><a class="header" href="#when-to-link">When to link</a></h2>
<p>Where links add clarity without duplicating docs.</p>
<ol>
<li>Point to source when explaining specific functions/types or design decisions.</li>
<li>Prefer linking to code over docs.rs when tying to this repo’s version.</li>
<li>For public API reference, optionally include a docs.rs link alongside the source link.</li>
</ol>
<h2 id="maintenance"><a class="header" href="#maintenance">Maintenance</a></h2>
<p>How to keep links accurate as code evolves.</p>
<ol>
<li>When code moves, update links in the same PR as the code change.</li>
<li>Keep links in crate pages and flow docs current after refactors.</li>
<li>If line numbers are likely to drift, consider linking to the symbol in docs.rs as a secondary reference.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="docsrs-alignment"><a class="header" href="#docsrs-alignment">docs.rs Alignment</a></h1>
<p><strong>Why</strong>: This book and docs.rs have different jobs, and that is a feature.
<strong>How it fits</strong>: Use docs.rs for exact API detail and this book for how pieces fit.
<strong>Learn more</strong>: See <a href="#linking-style">Linking Style</a>.</p>
<p>How this mdBook complements auto-generated docs.rs pages and stays current with releases.</p>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>Why both docs.rs and this book are needed.</p>
<ol>
<li>mdBook focuses on architecture, flows, design rationale, and curated examples across crates.</li>
<li>docs.rs provides API-level reference (types/functions) generated from each crate’s docs.</li>
<li>Together: use docs.rs for exact signatures and exhaustive items; use this book for how the pieces fit, constraints, and gotchas.</li>
</ol>
<h2 id="linking-strategy"><a class="header" href="#linking-strategy">Linking strategy</a></h2>
<p>How to connect mdBook pages with docs.rs and source references.</p>
<ol>
<li>For API details, link to docs.rs pages per crate (e.g., <code>https://docs.rs/cortenforge-sim-core/&lt;version&gt;/</code>).</li>
<li>When referencing specific items, prefer source links (<code>crate/module.rs:L123</code>) per the linking style guide to keep context tied to this repo’s version.</li>
<li>Add docs.rs links in crate overview pages where appropriate (e.g., top of each crate section).</li>
</ol>
<h2 id="keeping-in-sync-with-releases"><a class="header" href="#keeping-in-sync-with-releases">Keeping in sync with releases</a></h2>
<p>Checklist for keeping links and guidance current after changes.</p>
<ul>
<li>On each release/tag:
<ul>
<li>Update crate versions in docs.rs links if necessary.</li>
<li>Re-run <code>mdbook build</code> and skim for stale references (features, flows, config defaults).</li>
<li>Update <code>integration_contracts.md</code> if schemas/interfaces change.</li>
</ul>
</li>
<li>For breaking changes:
<ul>
<li>Add migration notes in <code>migration.md</code> or crate-specific design reviews.</li>
<li>Note deprecations and new features in crate overview pages and examples.</li>
</ul>
</li>
</ul>
<h2 id="scope-boundaries"><a class="header" href="#scope-boundaries">Scope boundaries</a></h2>
<p>What to keep in mdBook versus what to defer to docs.rs.</p>
<ol>
<li>mdBook intentionally omits auto-generated item listings; defer to docs.rs for exhaustive APIs.</li>
<li>Keep mdBook code snippets runnable/minimal; point to docs.rs for full API surface and trait bounds.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="maintenance-routine-weekly"><a class="header" href="#maintenance-routine-weekly">Maintenance Routine (Weekly)</a></h1>
<p><strong>Why</strong>: A short rhythm keeps the book aligned with the codebase.
<strong>How it fits</strong>: Do this after refactors or before a release.
<strong>Learn more</strong>: See <a href="#quality-gates">Quality Gates</a>.</p>
<p>Keep the CortenForge book aligned with the codebase and releases.</p>
<h2 id="weekly-checklist"><a class="header" href="#weekly-checklist">Weekly checklist</a></h2>
<p>Routine checks to keep docs aligned week to week.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Area</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>Build status</td><td>Run <code>mdbook build docs/cortenforge_book</code> to ensure no warnings/errors.</td></tr>
<tr><td>Feature flags</td><td>Review <code>feature_flags.md</code> for new/removed flags or defaults.</td></tr>
<tr><td>Flows &amp; contracts</td><td>Skim <code>canonical_flows.md</code> and <code>integration_contracts.md</code> after major refactors (capture/train/inference).</td></tr>
<tr><td>Crate chapters</td><td>Spot-check crates that changed; ensure public API/traits/error/perf/ownership pages still match code.</td></tr>
<tr><td>Open questions</td><td>Update statuses, add new unknowns as they appear.</td></tr>
<tr><td>Changelog</td><td>Add entries for notable changes (new crates, breaking changes, refactors).</td></tr>
<tr><td>Links</td><td>Verify <code>linking_style</code> usage and docs.rs links if versions bumped.</td></tr>
</tbody>
</table>
</div>
<h2 id="release-prep-when-taggingpublishing"><a class="header" href="#release-prep-when-taggingpublishing">Release prep (when tagging/publishing)</a></h2>
<p>Checklist to run only when cutting a release.</p>
<ol>
<li>Confirm <code>[patch]</code>/vendor notes are current; update <code>overview.md</code> and crate pages.</li>
<li>Update versions/links in <code>docsrs_alignment.md</code> if docs.rs URLs change.</li>
<li>Run <code>mdbook build</code> and fix warnings before publish.</li>
<li>Deploy: ensure the GitHub Actions <code>mdbook</code> workflow runs clean for the CortenForge book.</li>
</ol>
<h2 id="quick-commands"><a class="header" href="#quick-commands">Quick commands</a></h2>
<p>Common shortcuts for recurring maintenance tasks.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Purpose</th><th>Command</th></tr>
</thead>
<tbody>
<tr><td>Crate list, module tree, pub items.</td><td><code>tools/extract_for_book.sh</code></td></tr>
<tr><td>Build check.</td><td><code>mdbook build docs/cortenforge_book</code></td></tr>
<tr><td>Shortcut to build.</td><td><code>tools/book_tasks.sh build</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quality-gates"><a class="header" href="#quality-gates">Quality Gates</a></h1>
<p><strong>Why</strong>: Keep every page clear, short, and useful.
<strong>How it fits</strong>: Use this as a checklist when adding or updating pages.
<strong>Learn more</strong>: See <a href="#book-style-guide">Book Style Guide</a>.</p>
<p>Rules to keep the book concise, useful, and consistent.</p>
<h2 id="per-page-rules"><a class="header" href="#per-page-rules">Per-page rules</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rule</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>State the problem/purpose</td><td>Explain why the page exists up front.</td></tr>
<tr><td>Key types/actors</td><td>Name the important structs/traits/resources involved.</td></tr>
<tr><td>Invariants</td><td>List constraints/assumptions; note feature gates if relevant.</td></tr>
<tr><td>Example</td><td>Include at least one runnable/minimal snippet or command.</td></tr>
<tr><td>Gotchas</td><td>Capture pitfalls, edge cases, feature flags, and perf risks.</td></tr>
<tr><td>Links</td><td>Add source links (<code>crate/path.rs:L123</code>) and/or docs.rs links for referenced items.</td></tr>
<tr><td>Scope</td><td>Avoid duplicating exhaustive API docs; defer to docs.rs for signatures.</td></tr>
</tbody>
</table>
</div>
<h2 id="crate-chapter-checklist"><a class="header" href="#crate-chapter-checklist">Crate chapter checklist</a></h2>
<p>For each crate (<code>sim_core</code>, <code>vision_core</code>, <code>vision_runtime</code>, <code>data_contracts</code>, <code>capture_utils</code>, <code>models</code>, <code>training</code>, <code>inference</code>, <code>cli_support</code>, <code>burn_dataset</code>, <code>cortenforge-tools</code>, <code>cortenforge</code>):</p>
<p><strong>Use this checklist after significant crate changes (API, feature flags, or module layout) and again before tagging a release.</strong></p>
<ul>
<li><input disabled="" type="checkbox"> <code>01_overview.md</code>: Purpose/scope/non-goals clear; links to docs.rs/source.</li>
<li><input disabled="" type="checkbox"> <code>02_public_api.md</code>: Table of pub items present; aligns with current code.</li>
<li><input disabled="" type="checkbox"> <code>03_lifecycle.md</code>: Construction/usage narrative accurate.</li>
<li><input disabled="" type="checkbox"> <code>04_module_map.md</code>: Modules listed with responsibilities.</li>
<li><input disabled="" type="checkbox"> <code>05_traits_and_generics.md</code>: Extensibility/constraints captured.</li>
<li><input disabled="" type="checkbox"> <code>06_error_model.md</code>: Error surfaces and handling noted.</li>
<li><input disabled="" type="checkbox"> <code>07_ownership_and_concurrency.md</code>: Send/Sync/async/borrowing captured.</li>
<li><input disabled="" type="checkbox"> <code>08_performance_notes.md</code>: Hot paths/alloc/cloning highlighted.</li>
<li><input disabled="" type="checkbox"> <code>09_examples.md</code>: 2–3 minimal examples compile in principle.</li>
<li><input disabled="" type="checkbox"> <code>10_design_review.md</code>: Strengths/risks/refactors noted.</li>
</ul>
<h2 id="progress-publish-order"><a class="header" href="#progress-publish-order">Progress (publish order)</a></h2>
<p>Track which crate pages were verified for the latest release version.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Status</th><th>Version</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>data_contracts</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>models</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>burn_dataset</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>cli_support</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>vision_core</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>sim_core</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>capture_utils</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>inference</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>vision_runtime</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>training</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
<tr><td>cortenforge</td><td>complete</td><td>0.1.1</td><td>01–10 verified</td></tr>
</tbody>
</table>
</div>
<h2 id="cross-workspace-pages"><a class="header" href="#cross-workspace-pages">Cross-workspace pages</a></h2>
<p>Keep shared “glue” docs in sync so cross-cutting flows and conventions stay accurate.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Page</th><th>Maintenance focus</th></tr>
</thead>
<tbody>
<tr><td><code>canonical_flows.md</code></td><td>Flows stay current with crate changes; diagrams updated.</td></tr>
<tr><td><code>integration_contracts.md</code></td><td>Assumptions updated when interfaces/schemas change.</td></tr>
<tr><td><code>docsrs_alignment.md</code> &amp; <code>linking_style.md</code></td><td>Reflect current linking conventions.</td></tr>
</tbody>
</table>
</div>
<h2 id="update-cadence"><a class="header" href="#update-cadence">Update cadence</a></h2>
<p>When to re-run checks so the book stays accurate between releases.</p>
<ol>
<li>On each release/tag: run through the crate checklist and flows; update line links if code moved.</li>
<li>When adding a crate: scaffold full set of pages + add to <code>SUMMARY.md</code> and checklists.</li>
<li>When removing/migrating a crate (e.g., <code>cortenforge-tools</code> split): update flows, integration contracts, and remove chapters as appropriate.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="open-questions"><a class="header" href="#open-questions">Open Questions</a></h1>
<p><strong>Why</strong>: Keep uncertainty visible so it gets resolved.
<strong>How it fits</strong>: Use this after deep dives or during refactors.
<strong>Learn more</strong>: See <a href="#maintenance-routine-weekly">Maintenance Routine</a>.</p>
<p>Use this page to track unknowns and where to investigate. Add/remove entries as they’re answered.</p>
<h2 id="current-questions"><a class="header" href="#current-questions">Current questions</a></h2>
<ol>
<li>(none) — add entries below as needed.</li>
</ol>
<h2 id="template"><a class="header" href="#template">Template</a></h2>
<ol>
<li><strong>Question</strong>: &lt;what do we need to know?&gt;</li>
<li><strong>Where to look</strong>: &lt;files/modules/tests to inspect&gt;</li>
<li><strong>Status</strong>: Unanswered / In progress / Answered</li>
<li><strong>Notes</strong>: &lt;findings, hypotheses, links&gt;</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example:</a></h3>
<p><strong>Question</strong>: Should <code>capture_utils::generate_overlays</code> log skipped files?<br><strong>Where to look</strong>: <code>capture_utils/src/lib.rs</code>, overlay generation loop.<br><strong>Status</strong>: Unanswered.<br><strong>Notes</strong>: Currently silent; consider adding logging for missing images.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog-guide-mdbook"><a class="header" href="#changelog-guide-mdbook">Changelog Guide (mdBook)</a></h1>
<p><strong>Why</strong>: Capture the changes that affect readers and maintainers.
<strong>How it fits</strong>: Update this alongside real code changes.
<strong>Learn more</strong>: See <a href="#maintenance-routine-weekly">Maintenance Routine</a>.</p>
<p>How to track workspace changes and keep the book current.</p>
<h2 id="what-to-record"><a class="header" href="#what-to-record">What to record</a></h2>
<p>Quick scan of change categories that should land in the changelog.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Change type</th><th>What to capture</th></tr>
</thead>
<tbody>
<tr><td>New crates</td><td>Name, path, purpose, publish status, feature flags. Add crate chapter and update <code>SUMMARY.md</code>.</td></tr>
<tr><td>Breaking changes</td><td>APIs removed/renamed, schema changes (<code>data_contracts</code>), feature flag defaults, backend changes.</td></tr>
<tr><td>Refactors</td><td>Module moves, file relocations, flow changes (capture, training, inference), dependency bumps that alter behavior.</td></tr>
<tr><td>Deletions/migrations</td><td>Crates removed or moved to other repos (e.g., <code>cortenforge-tools</code> split); note where content moved.</td></tr>
<tr><td>Release milestones</td><td>Versions published, tags, lockfile updates if they change interfaces.</td></tr>
</tbody>
</table>
</div>
<h2 id="update-process"><a class="header" href="#update-process">Update process</a></h2>
<p>Steps to keep the book synchronized after adding a changelog entry.</p>
<ol>
<li>Add an entry under the current date/version with a short summary and impacted crates.</li>
<li>Update related pages:
<ul>
<li>Crate chapters (overviews, module maps, APIs, lifecycles).</li>
<li><code>canonical_flows.md</code> and <code>integration_contracts.md</code> if interfaces/flows changed.</li>
<li><code>SUMMARY.md</code> when adding/removing chapters.</li>
<li>README / RELEASE notes if public-facing changes.</li>
</ul>
</li>
<li>Run <code>mdbook build</code> to ensure navigation/linking is valid.</li>
</ol>
<h2 id="template-entry"><a class="header" href="#template-entry">Template entry</a></h2>
<p>Copy/paste scaffold for new release notes.</p>
<pre><code class="language-text">## YYYY-MM-DD (v{x}.{x}.{x})
- Changed: &lt;describe change and crates affected&gt;
- Impact: &lt;breaking?/compatible?&gt;; &lt;any migration steps&gt;
- Actions taken: &lt;pages updated, diagrams refreshed&gt;
</code></pre>
<h3 id="2026-01-09-v013"><a class="header" href="#2026-01-09-v013">2026-01-09 (v0.1.3)</a></h3>
<ul>
<li>Changed: publish <code>cortenforge-tools</code> and add it as an optional feature in the <code>cortenforge</code> umbrella.</li>
</ul>
<h3 id="2026-01-09-v012"><a class="header" href="#2026-01-09-v012">2026-01-09 (v0.1.2)</a></h3>
<ul>
<li>Changed: consolidated docs into <code>cortenforge_book</code> and removed legacy books.</li>
<li>Changed: added a calm “Building Apps” path and simplified the crate overview/deep‑dive split.</li>
<li>Changed: renamed and refactored <code>cortenforge-tools</code> with config support and clearer defaults.</li>
<li>Changed: bumped workspace crate versions to <code>0.1.2</code>.</li>
</ul>
<h3 id="2026-01-07-v011"><a class="header" href="#2026-01-07-v011">2026-01-07 (v0.1.1)</a></h3>
<p>Example entry showing the expected level of detail.</p>
<ul>
<li>Changed: aligned workspace crates to <code>0.1.1</code>; refreshed docs/version references; removed burn-core vendor patch and updated to 0.14.1.</li>
<li>Docs: completed quality-gates sweep across crate chapters; added source/docs.rs links and aligned examples with current APIs.</li>
<li>Impact: compatible; no API breaks expected beyond version alignment.</li>
<li>Actions taken: updated crate metadata/release checklist; staged publish order and notes.</li>
</ul>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<p>Short guidance for keeping entries useful and readable over time.</p>
<ul>
<li>Keep entries concise; link to PRs or commits for detail.</li>
<li>Prefer grouping related changes per release rather than per-commit noise.</li>
<li>When unsure, err on the side of documenting breaking behavior and feature flag changes.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/mermaid-616a109f.min.js"></script>
        <script src="theme/mermaid-init-ddd6903b.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
